// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: protobuf_seginfo_storage.proto

package pipeline.plugins.c_plugins;

@SuppressWarnings({ "unused", "static-access" })
public final class ProtobufSeedsOrCells {
	private ProtobufSeedsOrCells() {
	}

	public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry) {
	}

	public interface SegInfoOrBuilder extends com.google.protobuf.MessageLiteOrBuilder {

		// repeated int32 image_fullseg_coords_y = 1 [packed = true];
		java.util.List<java.lang.Integer> getImageFullsegCoordsYList();

		int getImageFullsegCoordsYCount();

		int getImageFullsegCoordsY(int index);

		// repeated int32 image_fullseg_coords_x = 2 [packed = true];
		java.util.List<java.lang.Integer> getImageFullsegCoordsXList();

		int getImageFullsegCoordsXCount();

		int getImageFullsegCoordsX(int index);

		// repeated int32 image_fullseg_coords_z = 3 [packed = true];
		java.util.List<java.lang.Integer> getImageFullsegCoordsZList();

		int getImageFullsegCoordsZCount();

		int getImageFullsegCoordsZ(int index);

		// repeated int32 image_perimseg_coords_y = 4 [packed = true];
		java.util.List<java.lang.Integer> getImagePerimsegCoordsYList();

		int getImagePerimsegCoordsYCount();

		int getImagePerimsegCoordsY(int index);

		// repeated int32 image_perimseg_coords_x = 5 [packed = true];
		java.util.List<java.lang.Integer> getImagePerimsegCoordsXList();

		int getImagePerimsegCoordsXCount();

		int getImagePerimsegCoordsX(int index);

		// repeated int32 image_perimseg_coords_z = 6 [packed = true];
		java.util.List<java.lang.Integer> getImagePerimsegCoordsZList();

		int getImagePerimsegCoordsZCount();

		int getImagePerimsegCoordsZ(int index);

		// repeated int32 image_userseg_coords_y = 7 [packed = true];
		java.util.List<java.lang.Integer> getImageUsersegCoordsYList();

		int getImageUsersegCoordsYCount();

		int getImageUsersegCoordsY(int index);

		// repeated int32 image_userseg_coords_x = 8 [packed = true];
		java.util.List<java.lang.Integer> getImageUsersegCoordsXList();

		int getImageUsersegCoordsXCount();

		int getImageUsersegCoordsX(int index);

		// repeated int32 image_userseg_coords_z = 9 [packed = true];
		java.util.List<java.lang.Integer> getImageUsersegCoordsZList();

		int getImageUsersegCoordsZCount();

		int getImageUsersegCoordsZ(int index);

		// repeated float quantifiedProperties = 10;
		java.util.List<java.lang.Float> getQuantifiedPropertiesList();

		int getQuantifiedPropertiesCount();

		float getQuantifiedProperties(int index);

		// repeated float userCellValue = 11;
		java.util.List<java.lang.Float> getUserCellValueList();

		int getUserCellValueCount();

		float getUserCellValue(int index);

		// repeated string userCellFormula = 12;
		java.util.List<String> getUserCellFormulaList();

		int getUserCellFormulaCount();

		String getUserCellFormula(int index);

		// optional float idx = 13;
		boolean hasIdx();

		float getIdx();

		// optional float seed_y = 14;
		boolean hasSeedY();

		float getSeedY();

		// optional float seed_x = 15;
		boolean hasSeedX();

		float getSeedX();

		// optional float seed_z = 16;
		boolean hasSeedZ();

		float getSeedZ();

		// optional float seed_manual = 17;
		boolean hasSeedManual();

		float getSeedManual();

		// optional float contour_AddRemoveMerge = 18;
		boolean hasContourAddRemoveMerge();

		float getContourAddRemoveMerge();

		// optional float contour_MergeGroup = 19;
		boolean hasContourMergeGroup();

		float getContourMergeGroup();

		// optional float contour_WindowSize = 20;
		boolean hasContourWindowSize();

		float getContourWindowSize();

		// optional float contour_Tmax = 21;
		boolean hasContourTmax();

		float getContourTmax();

		// optional float contour_segmethod = 22;
		boolean hasContourSegmethod();

		float getContourSegmethod();

		// optional float hand_validated = 23 [default = 1];
		boolean hasHandValidated();

		float getHandValidated();

		// optional float seed_hsz = 24;
		boolean hasSeedHsz();

		float getSeedHsz();

		// optional float seed_t1 = 25;
		boolean hasSeedT1();

		float getSeedT1();

		// optional float seed_t2 = 26;
		boolean hasSeedT2();

		float getSeedT2();

		// optional float seed_segmethod = 27;
		boolean hasSeedSegmethod();

		float getSeedSegmethod();
	}

	public static final class SegInfo extends com.google.protobuf.GeneratedMessageLite implements SegInfoOrBuilder {
		// Use SegInfo.newBuilder() to construct.
		private SegInfo(Builder builder) {
			super(builder);
		}

		private SegInfo(boolean noInit) {
		}

		private static final SegInfo defaultInstance;

		public static SegInfo getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public SegInfo getDefaultInstanceForType() {
			return defaultInstance;
		}

		private int bitField0_;
		// repeated int32 image_fullseg_coords_y = 1 [packed = true];
		public static final int IMAGE_FULLSEG_COORDS_Y_FIELD_NUMBER = 1;
		private int[] imageFullsegCoordsY_;

		private static java.util.List<java.lang.Integer> imageFullsegCoordsYArray2list(int[] imageFullsegCoordsY) {
			if (imageFullsegCoordsY == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageFullsegCoordsY.length);
			for (int f : imageFullsegCoordsY)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageFullsegCoordsYArray2list(int[] imageFullsegCoordsY,
				int sizeLimit) {
			if (imageFullsegCoordsY == null)
				return null;
			int num2Copy = java.lang.Math.min(imageFullsegCoordsY.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageFullsegCoordsY[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageFullsegCoordsYList() {
			if (imageFullsegCoordsY_ != null)
				return java.util.Collections.unmodifiableList(imageFullsegCoordsYArray2list(imageFullsegCoordsY_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageFullsegCoordsYCount() {
			return imageFullsegCoordsY_ != null ? imageFullsegCoordsY_.length : 0;
		}

		@Override
		public int getImageFullsegCoordsY(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageFullsegCoordsY_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageFullsegCoordsYArray() {
			return imageFullsegCoordsY_;
		}

		private int imageFullsegCoordsYMemoizedSerializedSize = -1;

		// repeated int32 image_fullseg_coords_x = 2 [packed = true];
		public static final int IMAGE_FULLSEG_COORDS_X_FIELD_NUMBER = 2;
		private int[] imageFullsegCoordsX_;

		private static java.util.List<java.lang.Integer> imageFullsegCoordsXArray2list(int[] imageFullsegCoordsX) {
			if (imageFullsegCoordsX == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageFullsegCoordsX.length);
			for (int f : imageFullsegCoordsX)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageFullsegCoordsXArray2list(int[] imageFullsegCoordsX,
				int sizeLimit) {
			if (imageFullsegCoordsX == null)
				return null;
			int num2Copy = java.lang.Math.min(imageFullsegCoordsX.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageFullsegCoordsX[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageFullsegCoordsXList() {
			if (imageFullsegCoordsX_ != null)
				return java.util.Collections.unmodifiableList(imageFullsegCoordsXArray2list(imageFullsegCoordsX_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageFullsegCoordsXCount() {
			return imageFullsegCoordsX_ != null ? imageFullsegCoordsX_.length : 0;
		}

		@Override
		public int getImageFullsegCoordsX(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageFullsegCoordsX_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageFullsegCoordsXArray() {
			return imageFullsegCoordsX_;
		}

		private int imageFullsegCoordsXMemoizedSerializedSize = -1;

		// repeated int32 image_fullseg_coords_z = 3 [packed = true];
		public static final int IMAGE_FULLSEG_COORDS_Z_FIELD_NUMBER = 3;
		private int[] imageFullsegCoordsZ_;

		private static java.util.List<java.lang.Integer> imageFullsegCoordsZArray2list(int[] imageFullsegCoordsZ) {
			if (imageFullsegCoordsZ == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageFullsegCoordsZ.length);
			for (int f : imageFullsegCoordsZ)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageFullsegCoordsZArray2list(int[] imageFullsegCoordsZ,
				int sizeLimit) {
			if (imageFullsegCoordsZ == null)
				return null;
			int num2Copy = java.lang.Math.min(imageFullsegCoordsZ.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageFullsegCoordsZ[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageFullsegCoordsZList() {
			if (imageFullsegCoordsZ_ != null)
				return java.util.Collections.unmodifiableList(imageFullsegCoordsZArray2list(imageFullsegCoordsZ_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageFullsegCoordsZCount() {
			return imageFullsegCoordsZ_ != null ? imageFullsegCoordsZ_.length : 0;
		}

		@Override
		public int getImageFullsegCoordsZ(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageFullsegCoordsZ_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageFullsegCoordsZArray() {
			return imageFullsegCoordsZ_;
		}

		private int imageFullsegCoordsZMemoizedSerializedSize = -1;

		// repeated int32 image_perimseg_coords_y = 4 [packed = true];
		public static final int IMAGE_PERIMSEG_COORDS_Y_FIELD_NUMBER = 4;
		private int[] imagePerimsegCoordsY_;

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsYArray2list(int[] imagePerimsegCoordsY) {
			if (imagePerimsegCoordsY == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imagePerimsegCoordsY.length);
			for (int f : imagePerimsegCoordsY)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsYArray2list(int[] imagePerimsegCoordsY,
				int sizeLimit) {
			if (imagePerimsegCoordsY == null)
				return null;
			int num2Copy = java.lang.Math.min(imagePerimsegCoordsY.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imagePerimsegCoordsY[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImagePerimsegCoordsYList() {
			if (imagePerimsegCoordsY_ != null)
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsYArray2list(imagePerimsegCoordsY_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImagePerimsegCoordsYCount() {
			return imagePerimsegCoordsY_ != null ? imagePerimsegCoordsY_.length : 0;
		}

		@Override
		public int getImagePerimsegCoordsY(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imagePerimsegCoordsY_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImagePerimsegCoordsYArray() {
			return imagePerimsegCoordsY_;
		}

		private int imagePerimsegCoordsYMemoizedSerializedSize = -1;

		// repeated int32 image_perimseg_coords_x = 5 [packed = true];
		public static final int IMAGE_PERIMSEG_COORDS_X_FIELD_NUMBER = 5;
		private int[] imagePerimsegCoordsX_;

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsXArray2list(int[] imagePerimsegCoordsX) {
			if (imagePerimsegCoordsX == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imagePerimsegCoordsX.length);
			for (int f : imagePerimsegCoordsX)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsXArray2list(int[] imagePerimsegCoordsX,
				int sizeLimit) {
			if (imagePerimsegCoordsX == null)
				return null;
			int num2Copy = java.lang.Math.min(imagePerimsegCoordsX.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imagePerimsegCoordsX[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImagePerimsegCoordsXList() {
			if (imagePerimsegCoordsX_ != null)
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsXArray2list(imagePerimsegCoordsX_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImagePerimsegCoordsXCount() {
			return imagePerimsegCoordsX_ != null ? imagePerimsegCoordsX_.length : 0;
		}

		@Override
		public int getImagePerimsegCoordsX(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imagePerimsegCoordsX_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImagePerimsegCoordsXArray() {
			return imagePerimsegCoordsX_;
		}

		private int imagePerimsegCoordsXMemoizedSerializedSize = -1;

		// repeated int32 image_perimseg_coords_z = 6 [packed = true];
		public static final int IMAGE_PERIMSEG_COORDS_Z_FIELD_NUMBER = 6;
		private int[] imagePerimsegCoordsZ_;

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsZArray2list(int[] imagePerimsegCoordsZ) {
			if (imagePerimsegCoordsZ == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imagePerimsegCoordsZ.length);
			for (int f : imagePerimsegCoordsZ)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imagePerimsegCoordsZArray2list(int[] imagePerimsegCoordsZ,
				int sizeLimit) {
			if (imagePerimsegCoordsZ == null)
				return null;
			int num2Copy = java.lang.Math.min(imagePerimsegCoordsZ.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imagePerimsegCoordsZ[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImagePerimsegCoordsZList() {
			if (imagePerimsegCoordsZ_ != null)
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsZArray2list(imagePerimsegCoordsZ_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImagePerimsegCoordsZCount() {
			return imagePerimsegCoordsZ_ != null ? imagePerimsegCoordsZ_.length : 0;
		}

		@Override
		public int getImagePerimsegCoordsZ(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imagePerimsegCoordsZ_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImagePerimsegCoordsZArray() {
			return imagePerimsegCoordsZ_;
		}

		private int imagePerimsegCoordsZMemoizedSerializedSize = -1;

		// repeated int32 image_userseg_coords_y = 7 [packed = true];
		public static final int IMAGE_USERSEG_COORDS_Y_FIELD_NUMBER = 7;
		private int[] imageUsersegCoordsY_;

		private static java.util.List<java.lang.Integer> imageUsersegCoordsYArray2list(int[] imageUsersegCoordsY) {
			if (imageUsersegCoordsY == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageUsersegCoordsY.length);
			for (int f : imageUsersegCoordsY)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageUsersegCoordsYArray2list(int[] imageUsersegCoordsY,
				int sizeLimit) {
			if (imageUsersegCoordsY == null)
				return null;
			int num2Copy = java.lang.Math.min(imageUsersegCoordsY.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageUsersegCoordsY[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageUsersegCoordsYList() {
			if (imageUsersegCoordsY_ != null)
				return java.util.Collections.unmodifiableList(imageUsersegCoordsYArray2list(imageUsersegCoordsY_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageUsersegCoordsYCount() {
			return imageUsersegCoordsY_ != null ? imageUsersegCoordsY_.length : 0;
		}

		@Override
		public int getImageUsersegCoordsY(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageUsersegCoordsY_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageUsersegCoordsYArray() {
			return imageUsersegCoordsY_;
		}

		private int imageUsersegCoordsYMemoizedSerializedSize = -1;

		// repeated int32 image_userseg_coords_x = 8 [packed = true];
		public static final int IMAGE_USERSEG_COORDS_X_FIELD_NUMBER = 8;
		private int[] imageUsersegCoordsX_;

		private static java.util.List<java.lang.Integer> imageUsersegCoordsXArray2list(int[] imageUsersegCoordsX) {
			if (imageUsersegCoordsX == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageUsersegCoordsX.length);
			for (int f : imageUsersegCoordsX)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageUsersegCoordsXArray2list(int[] imageUsersegCoordsX,
				int sizeLimit) {
			if (imageUsersegCoordsX == null)
				return null;
			int num2Copy = java.lang.Math.min(imageUsersegCoordsX.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageUsersegCoordsX[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageUsersegCoordsXList() {
			if (imageUsersegCoordsX_ != null)
				return java.util.Collections.unmodifiableList(imageUsersegCoordsXArray2list(imageUsersegCoordsX_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageUsersegCoordsXCount() {
			return imageUsersegCoordsX_ != null ? imageUsersegCoordsX_.length : 0;
		}

		@Override
		public int getImageUsersegCoordsX(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageUsersegCoordsX_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageUsersegCoordsXArray() {
			return imageUsersegCoordsX_;
		}

		private int imageUsersegCoordsXMemoizedSerializedSize = -1;

		// repeated int32 image_userseg_coords_z = 9 [packed = true];
		public static final int IMAGE_USERSEG_COORDS_Z_FIELD_NUMBER = 9;
		private int[] imageUsersegCoordsZ_;

		private static java.util.List<java.lang.Integer> imageUsersegCoordsZArray2list(int[] imageUsersegCoordsZ) {
			if (imageUsersegCoordsZ == null)
				return null;
			java.util.ArrayList<java.lang.Integer> retList =
					new java.util.ArrayList<java.lang.Integer>(imageUsersegCoordsZ.length);
			for (int f : imageUsersegCoordsZ)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Integer> imageUsersegCoordsZArray2list(int[] imageUsersegCoordsZ,
				int sizeLimit) {
			if (imageUsersegCoordsZ == null)
				return null;
			int num2Copy = java.lang.Math.min(imageUsersegCoordsZ.length, sizeLimit);
			java.util.ArrayList<java.lang.Integer> retList = new java.util.ArrayList<java.lang.Integer>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(imageUsersegCoordsZ[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Integer> getImageUsersegCoordsZList() {
			if (imageUsersegCoordsZ_ != null)
				return java.util.Collections.unmodifiableList(imageUsersegCoordsZArray2list(imageUsersegCoordsZ_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getImageUsersegCoordsZCount() {
			return imageUsersegCoordsZ_ != null ? imageUsersegCoordsZ_.length : 0;
		}

		@Override
		public int getImageUsersegCoordsZ(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return imageUsersegCoordsZ_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public int[] getImageUsersegCoordsZArray() {
			return imageUsersegCoordsZ_;
		}

		private int imageUsersegCoordsZMemoizedSerializedSize = -1;

		// repeated float quantifiedProperties = 10;
		public static final int QUANTIFIEDPROPERTIES_FIELD_NUMBER = 10;
		private float[] quantifiedProperties_;

		private static java.util.List<java.lang.Float> quantifiedPropertiesArray2list(float[] quantifiedProperties) {
			if (quantifiedProperties == null)
				return null;
			java.util.ArrayList<java.lang.Float> retList =
					new java.util.ArrayList<java.lang.Float>(quantifiedProperties.length);
			for (float f : quantifiedProperties)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Float> quantifiedPropertiesArray2list(float[] quantifiedProperties,
				int sizeLimit) {
			if (quantifiedProperties == null)
				return null;
			int num2Copy = java.lang.Math.min(quantifiedProperties.length, sizeLimit);
			java.util.ArrayList<java.lang.Float> retList = new java.util.ArrayList<java.lang.Float>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(quantifiedProperties[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Float> getQuantifiedPropertiesList() {
			if (quantifiedProperties_ != null)
				return java.util.Collections.unmodifiableList(quantifiedPropertiesArray2list(quantifiedProperties_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getQuantifiedPropertiesCount() {
			return quantifiedProperties_ != null ? quantifiedProperties_.length : 0;
		}

		@Override
		public float getQuantifiedProperties(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return quantifiedProperties_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public float[] getQuantifiedPropertiesArray() {
			return quantifiedProperties_;
		}

		// repeated float userCellValue = 11;
		public static final int USERCELLVALUE_FIELD_NUMBER = 11;
		private float[] userCellValue_;

		private static java.util.List<java.lang.Float> userCellValueArray2list(float[] userCellValue) {
			if (userCellValue == null)
				return null;
			java.util.ArrayList<java.lang.Float> retList =
					new java.util.ArrayList<java.lang.Float>(userCellValue.length);
			for (float f : userCellValue)
				retList.add(f);
			return retList;
		}

		private static java.util.List<java.lang.Float> userCellValueArray2list(float[] userCellValue, int sizeLimit) {
			if (userCellValue == null)
				return null;
			int num2Copy = java.lang.Math.min(userCellValue.length, sizeLimit);
			java.util.ArrayList<java.lang.Float> retList = new java.util.ArrayList<java.lang.Float>(num2Copy);
			for (int i = 0; i < num2Copy; ++i)
				retList.add(userCellValue[i]);
			return retList;
		}

		@Override
		public java.util.List<java.lang.Float> getUserCellValueList() {
			if (userCellValue_ != null)
				return java.util.Collections.unmodifiableList(userCellValueArray2list(userCellValue_));
			else
				return java.util.Collections.emptyList();
		}

		@Override
		public int getUserCellValueCount() {
			return userCellValue_ != null ? userCellValue_.length : 0;
		}

		@Override
		public float getUserCellValue(int index) {
			// Note: don't check data_ if someone attempts
			// to grab on index that isn't available. Allow
			// JRE to simply throw NullPointException
			// or IndexOutOfBoundsException
			return userCellValue_[index];
		}

		// Note: that this exposes mutable data
		// for essentially an immutable type
		// To absolutely conform to the standard
		// we'd want to clone this array before
		// passing back but that would just incur
		// more inefficiency.
		public float[] getUserCellValueArray() {
			return userCellValue_;
		}

		// repeated string userCellFormula = 12;
		public static final int USERCELLFORMULA_FIELD_NUMBER = 12;
		private com.google.protobuf.LazyStringList userCellFormula_;

		@Override
		public java.util.List<String> getUserCellFormulaList() {
			return userCellFormula_;
		}

		@Override
		public int getUserCellFormulaCount() {
			return userCellFormula_.size();
		}

		@Override
		public String getUserCellFormula(int index) {
			return userCellFormula_.get(index);
		}

		// optional float idx = 13;
		public static final int IDX_FIELD_NUMBER = 13;
		private float idx_;

		@Override
		public boolean hasIdx() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		@Override
		public float getIdx() {
			return idx_;
		}

		// optional float seed_y = 14;
		public static final int SEED_Y_FIELD_NUMBER = 14;
		private float seedY_;

		@Override
		public boolean hasSeedY() {
			return ((bitField0_ & 0x00000002) == 0x00000002);
		}

		@Override
		public float getSeedY() {
			return seedY_;
		}

		// optional float seed_x = 15;
		public static final int SEED_X_FIELD_NUMBER = 15;
		private float seedX_;

		@Override
		public boolean hasSeedX() {
			return ((bitField0_ & 0x00000004) == 0x00000004);
		}

		@Override
		public float getSeedX() {
			return seedX_;
		}

		// optional float seed_z = 16;
		public static final int SEED_Z_FIELD_NUMBER = 16;
		private float seedZ_;

		@Override
		public boolean hasSeedZ() {
			return ((bitField0_ & 0x00000008) == 0x00000008);
		}

		@Override
		public float getSeedZ() {
			return seedZ_;
		}

		// optional float seed_manual = 17;
		public static final int SEED_MANUAL_FIELD_NUMBER = 17;
		private float seedManual_;

		@Override
		public boolean hasSeedManual() {
			return ((bitField0_ & 0x00000010) == 0x00000010);
		}

		@Override
		public float getSeedManual() {
			return seedManual_;
		}

		// optional float contour_AddRemoveMerge = 18;
		public static final int CONTOUR_ADDREMOVEMERGE_FIELD_NUMBER = 18;
		private float contourAddRemoveMerge_;

		@Override
		public boolean hasContourAddRemoveMerge() {
			return ((bitField0_ & 0x00000020) == 0x00000020);
		}

		@Override
		public float getContourAddRemoveMerge() {
			return contourAddRemoveMerge_;
		}

		// optional float contour_MergeGroup = 19;
		public static final int CONTOUR_MERGEGROUP_FIELD_NUMBER = 19;
		private float contourMergeGroup_;

		@Override
		public boolean hasContourMergeGroup() {
			return ((bitField0_ & 0x00000040) == 0x00000040);
		}

		@Override
		public float getContourMergeGroup() {
			return contourMergeGroup_;
		}

		// optional float contour_WindowSize = 20;
		public static final int CONTOUR_WINDOWSIZE_FIELD_NUMBER = 20;
		private float contourWindowSize_;

		@Override
		public boolean hasContourWindowSize() {
			return ((bitField0_ & 0x00000080) == 0x00000080);
		}

		@Override
		public float getContourWindowSize() {
			return contourWindowSize_;
		}

		// optional float contour_Tmax = 21;
		public static final int CONTOUR_TMAX_FIELD_NUMBER = 21;
		private float contourTmax_;

		@Override
		public boolean hasContourTmax() {
			return ((bitField0_ & 0x00000100) == 0x00000100);
		}

		@Override
		public float getContourTmax() {
			return contourTmax_;
		}

		// optional float contour_segmethod = 22;
		public static final int CONTOUR_SEGMETHOD_FIELD_NUMBER = 22;
		private float contourSegmethod_;

		@Override
		public boolean hasContourSegmethod() {
			return ((bitField0_ & 0x00000200) == 0x00000200);
		}

		@Override
		public float getContourSegmethod() {
			return contourSegmethod_;
		}

		// optional float hand_validated = 23 [default = 1];
		public static final int HAND_VALIDATED_FIELD_NUMBER = 23;
		private float handValidated_;

		@Override
		public boolean hasHandValidated() {
			return ((bitField0_ & 0x00000400) == 0x00000400);
		}

		@Override
		public float getHandValidated() {
			return handValidated_;
		}

		// optional float seed_hsz = 24;
		public static final int SEED_HSZ_FIELD_NUMBER = 24;
		private float seedHsz_;

		@Override
		public boolean hasSeedHsz() {
			return ((bitField0_ & 0x00000800) == 0x00000800);
		}

		@Override
		public float getSeedHsz() {
			return seedHsz_;
		}

		// optional float seed_t1 = 25;
		public static final int SEED_T1_FIELD_NUMBER = 25;
		private float seedT1_;

		@Override
		public boolean hasSeedT1() {
			return ((bitField0_ & 0x00001000) == 0x00001000);
		}

		@Override
		public float getSeedT1() {
			return seedT1_;
		}

		// optional float seed_t2 = 26;
		public static final int SEED_T2_FIELD_NUMBER = 26;
		private float seedT2_;

		@Override
		public boolean hasSeedT2() {
			return ((bitField0_ & 0x00002000) == 0x00002000);
		}

		@Override
		public float getSeedT2() {
			return seedT2_;
		}

		// optional float seed_segmethod = 27;
		public static final int SEED_SEGMETHOD_FIELD_NUMBER = 27;
		private float seedSegmethod_;

		@Override
		public boolean hasSeedSegmethod() {
			return ((bitField0_ & 0x00004000) == 0x00004000);
		}

		@Override
		public float getSeedSegmethod() {
			return seedSegmethod_;
		}

		private void initFields() {
			imageFullsegCoordsY_ = null;
			imageFullsegCoordsX_ = null;
			imageFullsegCoordsZ_ = null;
			imagePerimsegCoordsY_ = null;
			imagePerimsegCoordsX_ = null;
			imagePerimsegCoordsZ_ = null;
			imageUsersegCoordsY_ = null;
			imageUsersegCoordsX_ = null;
			imageUsersegCoordsZ_ = null;
			quantifiedProperties_ = null;
			userCellValue_ = null;
			userCellFormula_ = com.google.protobuf.LazyStringArrayList.EMPTY;
			idx_ = 0F;
			seedY_ = 0F;
			seedX_ = 0F;
			seedZ_ = 0F;
			seedManual_ = 0F;
			contourAddRemoveMerge_ = 0F;
			contourMergeGroup_ = 0F;
			contourWindowSize_ = 0F;
			contourTmax_ = 0F;
			contourSegmethod_ = 0F;
			handValidated_ = 1F;
			seedHsz_ = 0F;
			seedT1_ = 0F;
			seedT2_ = 0F;
			seedSegmethod_ = 0F;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized != -1)
				return isInitialized == 1;

			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
			getSerializedSize();
			if (imageFullsegCoordsY_ != null && imageFullsegCoordsY_.length > 0) {
				output.writeRawVarint32(10);
				output.writeRawVarint32(imageFullsegCoordsYMemoizedSerializedSize);
				for (int i = 0; i < imageFullsegCoordsY_.length; ++i) {
					output.writeInt32NoTag(imageFullsegCoordsY_[i]);
				}
			}
			if (imageFullsegCoordsX_ != null && imageFullsegCoordsX_.length > 0) {
				output.writeRawVarint32(18);
				output.writeRawVarint32(imageFullsegCoordsXMemoizedSerializedSize);
				for (int i = 0; i < imageFullsegCoordsX_.length; ++i) {
					output.writeInt32NoTag(imageFullsegCoordsX_[i]);
				}
			}
			if (imageFullsegCoordsZ_ != null && imageFullsegCoordsZ_.length > 0) {
				output.writeRawVarint32(26);
				output.writeRawVarint32(imageFullsegCoordsZMemoizedSerializedSize);
				for (int i = 0; i < imageFullsegCoordsZ_.length; ++i) {
					output.writeInt32NoTag(imageFullsegCoordsZ_[i]);
				}
			}
			if (imagePerimsegCoordsY_ != null && imagePerimsegCoordsY_.length > 0) {
				output.writeRawVarint32(34);
				output.writeRawVarint32(imagePerimsegCoordsYMemoizedSerializedSize);
				for (int i = 0; i < imagePerimsegCoordsY_.length; ++i) {
					output.writeInt32NoTag(imagePerimsegCoordsY_[i]);
				}
			}
			if (imagePerimsegCoordsX_ != null && imagePerimsegCoordsX_.length > 0) {
				output.writeRawVarint32(42);
				output.writeRawVarint32(imagePerimsegCoordsXMemoizedSerializedSize);
				for (int i = 0; i < imagePerimsegCoordsX_.length; ++i) {
					output.writeInt32NoTag(imagePerimsegCoordsX_[i]);
				}
			}
			if (imagePerimsegCoordsZ_ != null && imagePerimsegCoordsZ_.length > 0) {
				output.writeRawVarint32(50);
				output.writeRawVarint32(imagePerimsegCoordsZMemoizedSerializedSize);
				for (int i = 0; i < imagePerimsegCoordsZ_.length; ++i) {
					output.writeInt32NoTag(imagePerimsegCoordsZ_[i]);
				}
			}
			if (imageUsersegCoordsY_ != null && imageUsersegCoordsY_.length > 0) {
				output.writeRawVarint32(58);
				output.writeRawVarint32(imageUsersegCoordsYMemoizedSerializedSize);
				for (int i = 0; i < imageUsersegCoordsY_.length; ++i) {
					output.writeInt32NoTag(imageUsersegCoordsY_[i]);
				}
			}
			if (imageUsersegCoordsX_ != null && imageUsersegCoordsX_.length > 0) {
				output.writeRawVarint32(66);
				output.writeRawVarint32(imageUsersegCoordsXMemoizedSerializedSize);
				for (int i = 0; i < imageUsersegCoordsX_.length; ++i) {
					output.writeInt32NoTag(imageUsersegCoordsX_[i]);
				}
			}
			if (imageUsersegCoordsZ_ != null && imageUsersegCoordsZ_.length > 0) {
				output.writeRawVarint32(74);
				output.writeRawVarint32(imageUsersegCoordsZMemoizedSerializedSize);
				for (int i = 0; i < imageUsersegCoordsZ_.length; ++i) {
					output.writeInt32NoTag(imageUsersegCoordsZ_[i]);
				}
			}
			for (int i = 0; i < quantifiedProperties_.length; ++i) {
				output.writeFloat(10, quantifiedProperties_[i]);
			}
			for (int i = 0; i < userCellValue_.length; ++i) {
				output.writeFloat(11, userCellValue_[i]);
			}
			for (int i = 0; i < userCellFormula_.size(); i++) {
				output.writeBytes(12, userCellFormula_.getByteString(i));
			}
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeFloat(13, idx_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				output.writeFloat(14, seedY_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				output.writeFloat(15, seedX_);
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				output.writeFloat(16, seedZ_);
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				output.writeFloat(17, seedManual_);
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				output.writeFloat(18, contourAddRemoveMerge_);
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				output.writeFloat(19, contourMergeGroup_);
			}
			if (((bitField0_ & 0x00000080) == 0x00000080)) {
				output.writeFloat(20, contourWindowSize_);
			}
			if (((bitField0_ & 0x00000100) == 0x00000100)) {
				output.writeFloat(21, contourTmax_);
			}
			if (((bitField0_ & 0x00000200) == 0x00000200)) {
				output.writeFloat(22, contourSegmethod_);
			}
			if (((bitField0_ & 0x00000400) == 0x00000400)) {
				output.writeFloat(23, handValidated_);
			}
			if (((bitField0_ & 0x00000800) == 0x00000800)) {
				output.writeFloat(24, seedHsz_);
			}
			if (((bitField0_ & 0x00001000) == 0x00001000)) {
				output.writeFloat(25, seedT1_);
			}
			if (((bitField0_ & 0x00002000) == 0x00002000)) {
				output.writeFloat(26, seedT2_);
			}
			if (((bitField0_ & 0x00004000) == 0x00004000)) {
				output.writeFloat(27, seedSegmethod_);
			}
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			{
				int dataSize = 0;
				for (int i = 0; i < imageFullsegCoordsY_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageFullsegCoordsY_[i]);
				}
				size += dataSize;
				if (getImageFullsegCoordsYCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageFullsegCoordsYMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imageFullsegCoordsX_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageFullsegCoordsX_[i]);
				}
				size += dataSize;
				if (getImageFullsegCoordsXCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageFullsegCoordsXMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imageFullsegCoordsZ_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageFullsegCoordsZ_[i]);
				}
				size += dataSize;
				if (getImageFullsegCoordsZCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageFullsegCoordsZMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imagePerimsegCoordsY_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imagePerimsegCoordsY_[i]);
				}
				size += dataSize;
				if (getImagePerimsegCoordsYCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imagePerimsegCoordsYMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imagePerimsegCoordsX_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imagePerimsegCoordsX_[i]);
				}
				size += dataSize;
				if (getImagePerimsegCoordsXCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imagePerimsegCoordsXMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imagePerimsegCoordsZ_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imagePerimsegCoordsZ_[i]);
				}
				size += dataSize;
				if (getImagePerimsegCoordsZCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imagePerimsegCoordsZMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imageUsersegCoordsY_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageUsersegCoordsY_[i]);
				}
				size += dataSize;
				if (getImageUsersegCoordsYCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageUsersegCoordsYMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imageUsersegCoordsX_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageUsersegCoordsX_[i]);
				}
				size += dataSize;
				if (getImageUsersegCoordsXCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageUsersegCoordsXMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				for (int i = 0; i < imageUsersegCoordsZ_.length; ++i) {
					dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(imageUsersegCoordsZ_[i]);
				}
				size += dataSize;
				if (getImageUsersegCoordsZCount() > 0) {
					size += 1;
					size += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize);
				}
				imageUsersegCoordsZMemoizedSerializedSize = dataSize;
			}
			{
				int dataSize = 0;
				dataSize = 4 * getQuantifiedPropertiesCount();
				size += dataSize;
				size += 1 * getQuantifiedPropertiesCount();
			}
			{
				int dataSize = 0;
				dataSize = 4 * getUserCellValueCount();
				size += dataSize;
				size += 1 * getUserCellValueCount();
			}
			{
				int dataSize = 0;
				for (int i = 0; i < userCellFormula_.size(); i++) {
					dataSize +=
							com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(userCellFormula_
									.getByteString(i));
				}
				size += dataSize;
				size += 1 * getUserCellFormulaList().size();
			}
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(13, idx_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(14, seedY_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(15, seedX_);
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(16, seedZ_);
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(17, seedManual_);
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(18, contourAddRemoveMerge_);
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(19, contourMergeGroup_);
			}
			if (((bitField0_ & 0x00000080) == 0x00000080)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(20, contourWindowSize_);
			}
			if (((bitField0_ & 0x00000100) == 0x00000100)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(21, contourTmax_);
			}
			if (((bitField0_ & 0x00000200) == 0x00000200)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(22, contourSegmethod_);
			}
			if (((bitField0_ & 0x00000400) == 0x00000400)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(23, handValidated_);
			}
			if (((bitField0_ & 0x00000800) == 0x00000800)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(24, seedHsz_);
			}
			if (((bitField0_ & 0x00001000) == 0x00001000)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(25, seedT1_);
			}
			if (((bitField0_ & 0x00002000) == 0x00002000)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(26, seedT2_);
			}
			if (((bitField0_ & 0x00004000) == 0x00004000)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(27, seedSegmethod_);
			}
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@java.lang.Override
		protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
			return super.writeReplace();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(
				com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(
				com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(byte[] data)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(byte[] data,
				com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return newBuilder().mergeFrom(input).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(java.io.InputStream input,
				com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return newBuilder().mergeFrom(input, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			Builder builder = newBuilder();
			if (builder.mergeDelimitedFrom(input)) {
				return builder.buildParsed();
			} else {
				return null;
			}
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseDelimitedFrom(
				java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws java.io.IOException {
			Builder builder = newBuilder();
			if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
				return builder.buildParsed();
			} else {
				return null;
			}
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo parseFrom(
				com.google.protobuf.CodedInputStream input) throws java.io.IOException {
			return newBuilder().mergeFrom(input).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo
				parseFrom(com.google.protobuf.CodedInputStream input,
						com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return newBuilder().mergeFrom(input, extensionRegistry).buildParsed();
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		public static final class Builder
				extends
				com.google.protobuf.GeneratedMessageLite.Builder<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo, Builder>
				implements pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfoOrBuilder {
			// Construct using pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				imageFullsegCoordsY_ = null;
				numUsedInImageFullsegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000001);
				imageFullsegCoordsX_ = null;
				numUsedInImageFullsegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000002);
				imageFullsegCoordsZ_ = null;
				numUsedInImageFullsegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000004);
				imagePerimsegCoordsY_ = null;
				numUsedInImagePerimsegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000008);
				imagePerimsegCoordsX_ = null;
				numUsedInImagePerimsegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000010);
				imagePerimsegCoordsZ_ = null;
				numUsedInImagePerimsegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000020);
				imageUsersegCoordsY_ = null;
				numUsedInImageUsersegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000040);
				imageUsersegCoordsX_ = null;
				numUsedInImageUsersegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000080);
				imageUsersegCoordsZ_ = null;
				numUsedInImageUsersegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000100);
				quantifiedProperties_ = null;
				numUsedInQuantifiedProperties_ = 0;
				bitField0_ = (bitField0_ & ~0x00000200);
				userCellValue_ = null;
				numUsedInUserCellValue_ = 0;
				bitField0_ = (bitField0_ & ~0x00000400);
				userCellFormula_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000800);
				idx_ = 0F;
				bitField0_ = (bitField0_ & ~0x00001000);
				seedY_ = 0F;
				bitField0_ = (bitField0_ & ~0x00002000);
				seedX_ = 0F;
				bitField0_ = (bitField0_ & ~0x00004000);
				seedZ_ = 0F;
				bitField0_ = (bitField0_ & ~0x00008000);
				seedManual_ = 0F;
				bitField0_ = (bitField0_ & ~0x00010000);
				contourAddRemoveMerge_ = 0F;
				bitField0_ = (bitField0_ & ~0x00020000);
				contourMergeGroup_ = 0F;
				bitField0_ = (bitField0_ & ~0x00040000);
				contourWindowSize_ = 0F;
				bitField0_ = (bitField0_ & ~0x00080000);
				contourTmax_ = 0F;
				bitField0_ = (bitField0_ & ~0x00100000);
				contourSegmethod_ = 0F;
				bitField0_ = (bitField0_ & ~0x00200000);
				handValidated_ = 1F;
				bitField0_ = (bitField0_ & ~0x00400000);
				seedHsz_ = 0F;
				bitField0_ = (bitField0_ & ~0x00800000);
				seedT1_ = 0F;
				bitField0_ = (bitField0_ & ~0x01000000);
				seedT2_ = 0F;
				bitField0_ = (bitField0_ & ~0x02000000);
				seedSegmethod_ = 0F;
				bitField0_ = (bitField0_ & ~0x04000000);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo getDefaultInstanceForType() {
				return pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.getDefaultInstance();
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo build() {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			private pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo buildParsed()
					throws com.google.protobuf.InvalidProtocolBufferException {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result).asInvalidProtocolBufferException();
				}
				return result;
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo buildPartial() {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo result =
						new pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo(this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((bitField0_ & 0x00000001) == 0x00000001)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageFullsegCoordsY_ = java.util.Collections.unmodifiableList(imageFullsegCoordsY_);
					bitField0_ = (bitField0_ & ~0x00000001);
				}
				result.imageFullsegCoordsY_ =
						imageFullsegCoordsY_ == null ? null : java.util.Arrays.copyOf(imageFullsegCoordsY_,
								numUsedInImageFullsegCoordsY_);
				if (((bitField0_ & 0x00000002) == 0x00000002)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageFullsegCoordsX_ = java.util.Collections.unmodifiableList(imageFullsegCoordsX_);
					bitField0_ = (bitField0_ & ~0x00000002);
				}
				result.imageFullsegCoordsX_ =
						imageFullsegCoordsX_ == null ? null : java.util.Arrays.copyOf(imageFullsegCoordsX_,
								numUsedInImageFullsegCoordsX_);
				if (((bitField0_ & 0x00000004) == 0x00000004)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageFullsegCoordsZ_ = java.util.Collections.unmodifiableList(imageFullsegCoordsZ_);
					bitField0_ = (bitField0_ & ~0x00000004);
				}
				result.imageFullsegCoordsZ_ =
						imageFullsegCoordsZ_ == null ? null : java.util.Arrays.copyOf(imageFullsegCoordsZ_,
								numUsedInImageFullsegCoordsZ_);
				if (((bitField0_ & 0x00000008) == 0x00000008)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imagePerimsegCoordsY_ = java.util.Collections.unmodifiableList(imagePerimsegCoordsY_);
					bitField0_ = (bitField0_ & ~0x00000008);
				}
				result.imagePerimsegCoordsY_ =
						imagePerimsegCoordsY_ == null ? null : java.util.Arrays.copyOf(imagePerimsegCoordsY_,
								numUsedInImagePerimsegCoordsY_);
				if (((bitField0_ & 0x00000010) == 0x00000010)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imagePerimsegCoordsX_ = java.util.Collections.unmodifiableList(imagePerimsegCoordsX_);
					bitField0_ = (bitField0_ & ~0x00000010);
				}
				result.imagePerimsegCoordsX_ =
						imagePerimsegCoordsX_ == null ? null : java.util.Arrays.copyOf(imagePerimsegCoordsX_,
								numUsedInImagePerimsegCoordsX_);
				if (((bitField0_ & 0x00000020) == 0x00000020)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imagePerimsegCoordsZ_ = java.util.Collections.unmodifiableList(imagePerimsegCoordsZ_);
					bitField0_ = (bitField0_ & ~0x00000020);
				}
				result.imagePerimsegCoordsZ_ =
						imagePerimsegCoordsZ_ == null ? null : java.util.Arrays.copyOf(imagePerimsegCoordsZ_,
								numUsedInImagePerimsegCoordsZ_);
				if (((bitField0_ & 0x00000040) == 0x00000040)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageUsersegCoordsY_ = java.util.Collections.unmodifiableList(imageUsersegCoordsY_);
					bitField0_ = (bitField0_ & ~0x00000040);
				}
				result.imageUsersegCoordsY_ =
						imageUsersegCoordsY_ == null ? null : java.util.Arrays.copyOf(imageUsersegCoordsY_,
								numUsedInImageUsersegCoordsY_);
				if (((bitField0_ & 0x00000080) == 0x00000080)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageUsersegCoordsX_ = java.util.Collections.unmodifiableList(imageUsersegCoordsX_);
					bitField0_ = (bitField0_ & ~0x00000080);
				}
				result.imageUsersegCoordsX_ =
						imageUsersegCoordsX_ == null ? null : java.util.Arrays.copyOf(imageUsersegCoordsX_,
								numUsedInImageUsersegCoordsX_);
				if (((bitField0_ & 0x00000100) == 0x00000100)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// imageUsersegCoordsZ_ = java.util.Collections.unmodifiableList(imageUsersegCoordsZ_);
					bitField0_ = (bitField0_ & ~0x00000100);
				}
				result.imageUsersegCoordsZ_ =
						imageUsersegCoordsZ_ == null ? null : java.util.Arrays.copyOf(imageUsersegCoordsZ_,
								numUsedInImageUsersegCoordsZ_);
				if (((bitField0_ & 0x00000200) == 0x00000200)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// quantifiedProperties_ = java.util.Collections.unmodifiableList(quantifiedProperties_);
					bitField0_ = (bitField0_ & ~0x00000200);
				}
				result.quantifiedProperties_ =
						quantifiedProperties_ == null ? null : java.util.Arrays.copyOf(quantifiedProperties_,
								numUsedInQuantifiedProperties_);
				if (((bitField0_ & 0x00000400) == 0x00000400)) {
					// Note: that it is not possible to make an array unmodifiable in Java
					// userCellValue_ = java.util.Collections.unmodifiableList(userCellValue_);
					bitField0_ = (bitField0_ & ~0x00000400);
				}
				result.userCellValue_ =
						userCellValue_ == null ? null : java.util.Arrays
								.copyOf(userCellValue_, numUsedInUserCellValue_);
				if (((bitField0_ & 0x00000800) == 0x00000800)) {
					userCellFormula_ = new com.google.protobuf.UnmodifiableLazyStringList(userCellFormula_);
					bitField0_ = (bitField0_ & ~0x00000800);
				}
				result.userCellFormula_ = userCellFormula_;
				if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
					to_bitField0_ |= 0x00000001;
				}
				result.idx_ = idx_;
				if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
					to_bitField0_ |= 0x00000002;
				}
				result.seedY_ = seedY_;
				if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
					to_bitField0_ |= 0x00000004;
				}
				result.seedX_ = seedX_;
				if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
					to_bitField0_ |= 0x00000008;
				}
				result.seedZ_ = seedZ_;
				if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
					to_bitField0_ |= 0x00000010;
				}
				result.seedManual_ = seedManual_;
				if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
					to_bitField0_ |= 0x00000020;
				}
				result.contourAddRemoveMerge_ = contourAddRemoveMerge_;
				if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
					to_bitField0_ |= 0x00000040;
				}
				result.contourMergeGroup_ = contourMergeGroup_;
				if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
					to_bitField0_ |= 0x00000080;
				}
				result.contourWindowSize_ = contourWindowSize_;
				if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
					to_bitField0_ |= 0x00000100;
				}
				result.contourTmax_ = contourTmax_;
				if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
					to_bitField0_ |= 0x00000200;
				}
				result.contourSegmethod_ = contourSegmethod_;
				if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
					to_bitField0_ |= 0x00000400;
				}
				result.handValidated_ = handValidated_;
				if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
					to_bitField0_ |= 0x00000800;
				}
				result.seedHsz_ = seedHsz_;
				if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
					to_bitField0_ |= 0x00001000;
				}
				result.seedT1_ = seedT1_;
				if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
					to_bitField0_ |= 0x00002000;
				}
				result.seedT2_ = seedT2_;
				if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
					to_bitField0_ |= 0x00004000;
				}
				result.seedSegmethod_ = seedSegmethod_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo other) {
				if (other == pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.getDefaultInstance())
					return this;
				if (other.imageFullsegCoordsY_ != null && other.imageFullsegCoordsY_.length > 0) {
					if (imageFullsegCoordsY_ == null) {
						imageFullsegCoordsY_ = other.imageFullsegCoordsY_;
						numUsedInImageFullsegCoordsY_ = other.imageFullsegCoordsY_.length;
						bitField0_ = (bitField0_ & ~0x00000001);
					} else {
						ensureImageFullsegCoordsYIsMutable();
						growImageFullsegCoordsYArray(other.imageFullsegCoordsY_.length);
						for (int i = 0; i < other.imageFullsegCoordsY_.length; ++i) {
							imageFullsegCoordsY_[numUsedInImageFullsegCoordsY_] = other.imageFullsegCoordsY_[i];
							++numUsedInImageFullsegCoordsY_;
						}
					}

				}
				if (other.imageFullsegCoordsX_ != null && other.imageFullsegCoordsX_.length > 0) {
					if (imageFullsegCoordsX_ == null) {
						imageFullsegCoordsX_ = other.imageFullsegCoordsX_;
						numUsedInImageFullsegCoordsX_ = other.imageFullsegCoordsX_.length;
						bitField0_ = (bitField0_ & ~0x00000002);
					} else {
						ensureImageFullsegCoordsXIsMutable();
						growImageFullsegCoordsXArray(other.imageFullsegCoordsX_.length);
						for (int i = 0; i < other.imageFullsegCoordsX_.length; ++i) {
							imageFullsegCoordsX_[numUsedInImageFullsegCoordsX_] = other.imageFullsegCoordsX_[i];
							++numUsedInImageFullsegCoordsX_;
						}
					}

				}
				if (other.imageFullsegCoordsZ_ != null && other.imageFullsegCoordsZ_.length > 0) {
					if (imageFullsegCoordsZ_ == null) {
						imageFullsegCoordsZ_ = other.imageFullsegCoordsZ_;
						numUsedInImageFullsegCoordsZ_ = other.imageFullsegCoordsZ_.length;
						bitField0_ = (bitField0_ & ~0x00000004);
					} else {
						ensureImageFullsegCoordsZIsMutable();
						growImageFullsegCoordsZArray(other.imageFullsegCoordsZ_.length);
						for (int i = 0; i < other.imageFullsegCoordsZ_.length; ++i) {
							imageFullsegCoordsZ_[numUsedInImageFullsegCoordsZ_] = other.imageFullsegCoordsZ_[i];
							++numUsedInImageFullsegCoordsZ_;
						}
					}

				}
				if (other.imagePerimsegCoordsY_ != null && other.imagePerimsegCoordsY_.length > 0) {
					if (imagePerimsegCoordsY_ == null) {
						imagePerimsegCoordsY_ = other.imagePerimsegCoordsY_;
						numUsedInImagePerimsegCoordsY_ = other.imagePerimsegCoordsY_.length;
						bitField0_ = (bitField0_ & ~0x00000008);
					} else {
						ensureImagePerimsegCoordsYIsMutable();
						growImagePerimsegCoordsYArray(other.imagePerimsegCoordsY_.length);
						for (int i = 0; i < other.imagePerimsegCoordsY_.length; ++i) {
							imagePerimsegCoordsY_[numUsedInImagePerimsegCoordsY_] = other.imagePerimsegCoordsY_[i];
							++numUsedInImagePerimsegCoordsY_;
						}
					}

				}
				if (other.imagePerimsegCoordsX_ != null && other.imagePerimsegCoordsX_.length > 0) {
					if (imagePerimsegCoordsX_ == null) {
						imagePerimsegCoordsX_ = other.imagePerimsegCoordsX_;
						numUsedInImagePerimsegCoordsX_ = other.imagePerimsegCoordsX_.length;
						bitField0_ = (bitField0_ & ~0x00000010);
					} else {
						ensureImagePerimsegCoordsXIsMutable();
						growImagePerimsegCoordsXArray(other.imagePerimsegCoordsX_.length);
						for (int i = 0; i < other.imagePerimsegCoordsX_.length; ++i) {
							imagePerimsegCoordsX_[numUsedInImagePerimsegCoordsX_] = other.imagePerimsegCoordsX_[i];
							++numUsedInImagePerimsegCoordsX_;
						}
					}

				}
				if (other.imagePerimsegCoordsZ_ != null && other.imagePerimsegCoordsZ_.length > 0) {
					if (imagePerimsegCoordsZ_ == null) {
						imagePerimsegCoordsZ_ = other.imagePerimsegCoordsZ_;
						numUsedInImagePerimsegCoordsZ_ = other.imagePerimsegCoordsZ_.length;
						bitField0_ = (bitField0_ & ~0x00000020);
					} else {
						ensureImagePerimsegCoordsZIsMutable();
						growImagePerimsegCoordsZArray(other.imagePerimsegCoordsZ_.length);
						for (int i = 0; i < other.imagePerimsegCoordsZ_.length; ++i) {
							imagePerimsegCoordsZ_[numUsedInImagePerimsegCoordsZ_] = other.imagePerimsegCoordsZ_[i];
							++numUsedInImagePerimsegCoordsZ_;
						}
					}

				}
				if (other.imageUsersegCoordsY_ != null && other.imageUsersegCoordsY_.length > 0) {
					if (imageUsersegCoordsY_ == null) {
						imageUsersegCoordsY_ = other.imageUsersegCoordsY_;
						numUsedInImageUsersegCoordsY_ = other.imageUsersegCoordsY_.length;
						bitField0_ = (bitField0_ & ~0x00000040);
					} else {
						ensureImageUsersegCoordsYIsMutable();
						growImageUsersegCoordsYArray(other.imageUsersegCoordsY_.length);
						for (int i = 0; i < other.imageUsersegCoordsY_.length; ++i) {
							imageUsersegCoordsY_[numUsedInImageUsersegCoordsY_] = other.imageUsersegCoordsY_[i];
							++numUsedInImageUsersegCoordsY_;
						}
					}

				}
				if (other.imageUsersegCoordsX_ != null && other.imageUsersegCoordsX_.length > 0) {
					if (imageUsersegCoordsX_ == null) {
						imageUsersegCoordsX_ = other.imageUsersegCoordsX_;
						numUsedInImageUsersegCoordsX_ = other.imageUsersegCoordsX_.length;
						bitField0_ = (bitField0_ & ~0x00000080);
					} else {
						ensureImageUsersegCoordsXIsMutable();
						growImageUsersegCoordsXArray(other.imageUsersegCoordsX_.length);
						for (int i = 0; i < other.imageUsersegCoordsX_.length; ++i) {
							imageUsersegCoordsX_[numUsedInImageUsersegCoordsX_] = other.imageUsersegCoordsX_[i];
							++numUsedInImageUsersegCoordsX_;
						}
					}

				}
				if (other.imageUsersegCoordsZ_ != null && other.imageUsersegCoordsZ_.length > 0) {
					if (imageUsersegCoordsZ_ == null) {
						imageUsersegCoordsZ_ = other.imageUsersegCoordsZ_;
						numUsedInImageUsersegCoordsZ_ = other.imageUsersegCoordsZ_.length;
						bitField0_ = (bitField0_ & ~0x00000100);
					} else {
						ensureImageUsersegCoordsZIsMutable();
						growImageUsersegCoordsZArray(other.imageUsersegCoordsZ_.length);
						for (int i = 0; i < other.imageUsersegCoordsZ_.length; ++i) {
							imageUsersegCoordsZ_[numUsedInImageUsersegCoordsZ_] = other.imageUsersegCoordsZ_[i];
							++numUsedInImageUsersegCoordsZ_;
						}
					}

				}
				if (other.quantifiedProperties_ != null && other.quantifiedProperties_.length > 0) {
					if (quantifiedProperties_ == null) {
						quantifiedProperties_ = other.quantifiedProperties_;
						numUsedInQuantifiedProperties_ = other.quantifiedProperties_.length;
						bitField0_ = (bitField0_ & ~0x00000200);
					} else {
						ensureQuantifiedPropertiesIsMutable();
						growQuantifiedPropertiesArray(other.quantifiedProperties_.length);
						for (int i = 0; i < other.quantifiedProperties_.length; ++i) {
							quantifiedProperties_[numUsedInQuantifiedProperties_] = other.quantifiedProperties_[i];
							++numUsedInQuantifiedProperties_;
						}
					}

				}
				if (other.userCellValue_ != null && other.userCellValue_.length > 0) {
					if (userCellValue_ == null) {
						userCellValue_ = other.userCellValue_;
						numUsedInUserCellValue_ = other.userCellValue_.length;
						bitField0_ = (bitField0_ & ~0x00000400);
					} else {
						ensureUserCellValueIsMutable();
						growUserCellValueArray(other.userCellValue_.length);
						for (int i = 0; i < other.userCellValue_.length; ++i) {
							userCellValue_[numUsedInUserCellValue_] = other.userCellValue_[i];
							++numUsedInUserCellValue_;
						}
					}

				}
				if (!other.userCellFormula_.isEmpty()) {
					if (userCellFormula_.isEmpty()) {
						userCellFormula_ = other.userCellFormula_;
						bitField0_ = (bitField0_ & ~0x00000800);
					} else {
						ensureUserCellFormulaIsMutable();
						userCellFormula_.addAll(other.userCellFormula_);
					}

				}
				if (other.hasIdx()) {
					setIdx(other.getIdx());
				}
				if (other.hasSeedY()) {
					setSeedY(other.getSeedY());
				}
				if (other.hasSeedX()) {
					setSeedX(other.getSeedX());
				}
				if (other.hasSeedZ()) {
					setSeedZ(other.getSeedZ());
				}
				if (other.hasSeedManual()) {
					setSeedManual(other.getSeedManual());
				}
				if (other.hasContourAddRemoveMerge()) {
					setContourAddRemoveMerge(other.getContourAddRemoveMerge());
				}
				if (other.hasContourMergeGroup()) {
					setContourMergeGroup(other.getContourMergeGroup());
				}
				if (other.hasContourWindowSize()) {
					setContourWindowSize(other.getContourWindowSize());
				}
				if (other.hasContourTmax()) {
					setContourTmax(other.getContourTmax());
				}
				if (other.hasContourSegmethod()) {
					setContourSegmethod(other.getContourSegmethod());
				}
				if (other.hasHandValidated()) {
					setHandValidated(other.getHandValidated());
				}
				if (other.hasSeedHsz()) {
					setSeedHsz(other.getSeedHsz());
				}
				if (other.hasSeedT1()) {
					setSeedT1(other.getSeedT1());
				}
				if (other.hasSeedT2()) {
					setSeedT2(other.getSeedT2());
				}
				if (other.hasSeedSegmethod()) {
					setSeedSegmethod(other.getSeedSegmethod());
				}
				return this;
			}

			@Override
			public final boolean isInitialized() {
				return true;
			}

			@Override
			public Builder mergeFrom(com.google.protobuf.CodedInputStream input,
					com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				while (true) {
					int tag = input.readTag();
					switch (tag) {
						case 0:

							return this;
						default: {
							if (!parseUnknownField(input, extensionRegistry, tag)) {

								return this;
							}
							break;
						}
						case 8: {
							// This extra case for the imageFullsegCoordsY field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageFullsegCoordsY(input.readInt32());
							break;
						}
						case 10: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageFullsegCoordsY(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 16: {
							// This extra case for the imageFullsegCoordsX field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageFullsegCoordsX(input.readInt32());
							break;
						}
						case 18: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageFullsegCoordsX(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 24: {
							// This extra case for the imageFullsegCoordsZ field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageFullsegCoordsZ(input.readInt32());
							break;
						}
						case 26: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageFullsegCoordsZ(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 32: {
							// This extra case for the imagePerimsegCoordsY field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImagePerimsegCoordsY(input.readInt32());
							break;
						}
						case 34: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImagePerimsegCoordsY(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 40: {
							// This extra case for the imagePerimsegCoordsX field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImagePerimsegCoordsX(input.readInt32());
							break;
						}
						case 42: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImagePerimsegCoordsX(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 48: {
							// This extra case for the imagePerimsegCoordsZ field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImagePerimsegCoordsZ(input.readInt32());
							break;
						}
						case 50: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImagePerimsegCoordsZ(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 56: {
							// This extra case for the imageUsersegCoordsY field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageUsersegCoordsY(input.readInt32());
							break;
						}
						case 58: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageUsersegCoordsY(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 64: {
							// This extra case for the imageUsersegCoordsX field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageUsersegCoordsX(input.readInt32());
							break;
						}
						case 66: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageUsersegCoordsX(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 72: {
							// This extra case for the imageUsersegCoordsZ field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addImageUsersegCoordsZ(input.readInt32());
							break;
						}
						case 74: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addImageUsersegCoordsZ(input.readInt32());
							}
							input.popLimit(limit);
							break;
						}
						case 85: {
							// This extra case for the quantifiedProperties field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addQuantifiedProperties(input.readFloat());
							break;
						}
						case 82: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addQuantifiedProperties(input.readFloat());
							}
							input.popLimit(limit);
							break;
						}
						case 93: {
							// This extra case for the userCellValue field is
							// used for extensibility in case the
							// field is changed in the future from
							// repeated to optional.
							addUserCellValue(input.readFloat());
							break;
						}
						case 90: {
							int length = input.readRawVarint32();
							int limit = input.pushLimit(length);
							while (input.getBytesUntilLimit() > 0) {
								addUserCellValue(input.readFloat());
							}
							input.popLimit(limit);
							break;
						}
						case 98: {
							ensureUserCellFormulaIsMutable();
							userCellFormula_.add(input.readBytes());
							break;
						}
						case 109: {
							bitField0_ |= 0x00001000;
							idx_ = input.readFloat();
							break;
						}
						case 117: {
							bitField0_ |= 0x00002000;
							seedY_ = input.readFloat();
							break;
						}
						case 125: {
							bitField0_ |= 0x00004000;
							seedX_ = input.readFloat();
							break;
						}
						case 133: {
							bitField0_ |= 0x00008000;
							seedZ_ = input.readFloat();
							break;
						}
						case 141: {
							bitField0_ |= 0x00010000;
							seedManual_ = input.readFloat();
							break;
						}
						case 149: {
							bitField0_ |= 0x00020000;
							contourAddRemoveMerge_ = input.readFloat();
							break;
						}
						case 157: {
							bitField0_ |= 0x00040000;
							contourMergeGroup_ = input.readFloat();
							break;
						}
						case 165: {
							bitField0_ |= 0x00080000;
							contourWindowSize_ = input.readFloat();
							break;
						}
						case 173: {
							bitField0_ |= 0x00100000;
							contourTmax_ = input.readFloat();
							break;
						}
						case 181: {
							bitField0_ |= 0x00200000;
							contourSegmethod_ = input.readFloat();
							break;
						}
						case 189: {
							bitField0_ |= 0x00400000;
							handValidated_ = input.readFloat();
							break;
						}
						case 197: {
							bitField0_ |= 0x00800000;
							seedHsz_ = input.readFloat();
							break;
						}
						case 205: {
							bitField0_ |= 0x01000000;
							seedT1_ = input.readFloat();
							break;
						}
						case 213: {
							bitField0_ |= 0x02000000;
							seedT2_ = input.readFloat();
							break;
						}
						case 221: {
							bitField0_ |= 0x04000000;
							seedSegmethod_ = input.readFloat();
							break;
						}
					}
				}
			}

			private int bitField0_;

			// repeated int32 image_fullseg_coords_y = 1 [packed = true];
			private int[] imageFullsegCoordsY_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageFullsegCoordsY_ = 0;

			public void ensureImageFullsegCoordsYIsMutable() {
				if (!((bitField0_ & 0x00000001) == 0x00000001)) {
					if (imageFullsegCoordsY_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageFullsegCoordsY_ = new int[20000];
					}
					bitField0_ |= 0x00000001;
				}
			}

			public void ensureImageFullsegCoordsYIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000001) == 0x00000001)) {
					if (imageFullsegCoordsY_ == null && initialSize > 0) {
						imageFullsegCoordsY_ = new int[initialSize];
					}
					bitField0_ |= 0x00000001;
				}
			}

			private void growImageFullsegCoordsYArray() {
				if (imageFullsegCoordsY_ == null) {
					ensureImageFullsegCoordsYIsMutable();
				} else if (numUsedInImageFullsegCoordsY_ >= imageFullsegCoordsY_.length) {
					// Grows our int[] by 20000 elements
					imageFullsegCoordsY_ =
							java.util.Arrays.copyOf(imageFullsegCoordsY_, imageFullsegCoordsY_.length + 20000);
				}
			}

			private void growImageFullsegCoordsYArray(int byAdditional) {
				if (imageFullsegCoordsY_ == null) {
					ensureImageFullsegCoordsYIsMutable();
				}
				if ((numUsedInImageFullsegCoordsY_ + byAdditional) >= imageFullsegCoordsY_.length) {
					imageFullsegCoordsY_ =
							java.util.Arrays.copyOf(imageFullsegCoordsY_, numUsedInImageFullsegCoordsY_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageFullsegCoordsYList() {
				return java.util.Collections.unmodifiableList(imageFullsegCoordsYArray2list(imageFullsegCoordsY_,
						numUsedInImageFullsegCoordsY_));
			}

			@Override
			public int getImageFullsegCoordsYCount() {
				return numUsedInImageFullsegCoordsY_;
			}

			@Override
			public int getImageFullsegCoordsY(int index) {
				if (index >= numUsedInImageFullsegCoordsY_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageFullsegCoordsY_[index];
			}

			// Note: It is not appropriate to add imageFullsegCoordsY to the returned
			// array because the internal counter numUsedInImageFullsegCoordsY_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageFullsegCoordsYArray() {
				return imageFullsegCoordsY_;
			}

			public Builder setImageFullsegCoordsY(int index, int value) {
				growImageFullsegCoordsYArray();
				imageFullsegCoordsY_[numUsedInImageFullsegCoordsY_] = value;

				return this;
			}

			public Builder addImageFullsegCoordsY(int value) {
				ensureImageFullsegCoordsYIsMutable();
				growImageFullsegCoordsYArray();
				imageFullsegCoordsY_[numUsedInImageFullsegCoordsY_] = value;
				++numUsedInImageFullsegCoordsY_;

				return this;
			}

			public Builder addAllImageFullsegCoordsY(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageFullsegCoordsYIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageFullsegCoordsYArray(growBy);
				for (java.lang.Integer f : values) {
					imageFullsegCoordsY_[numUsedInImageFullsegCoordsY_] = f;
					++numUsedInImageFullsegCoordsY_;
				}

				return this;
			}

			public Builder clearImageFullsegCoordsY() {
				imageFullsegCoordsY_ = null;
				numUsedInImageFullsegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000001);

				return this;
			}

			// repeated int32 image_fullseg_coords_x = 2 [packed = true];
			private int[] imageFullsegCoordsX_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageFullsegCoordsX_ = 0;

			public void ensureImageFullsegCoordsXIsMutable() {
				if (!((bitField0_ & 0x00000002) == 0x00000002)) {
					if (imageFullsegCoordsX_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageFullsegCoordsX_ = new int[20000];
					}
					bitField0_ |= 0x00000002;
				}
			}

			public void ensureImageFullsegCoordsXIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000002) == 0x00000002)) {
					if (imageFullsegCoordsX_ == null && initialSize > 0) {
						imageFullsegCoordsX_ = new int[initialSize];
					}
					bitField0_ |= 0x00000002;
				}
			}

			private void growImageFullsegCoordsXArray() {
				if (imageFullsegCoordsX_ == null) {
					ensureImageFullsegCoordsXIsMutable();
				} else if (numUsedInImageFullsegCoordsX_ >= imageFullsegCoordsX_.length) {
					// Grows our int[] by 20000 elements
					imageFullsegCoordsX_ =
							java.util.Arrays.copyOf(imageFullsegCoordsX_, imageFullsegCoordsX_.length + 20000);
				}
			}

			private void growImageFullsegCoordsXArray(int byAdditional) {
				if (imageFullsegCoordsX_ == null) {
					ensureImageFullsegCoordsXIsMutable();
				}
				if ((numUsedInImageFullsegCoordsX_ + byAdditional) >= imageFullsegCoordsX_.length) {
					imageFullsegCoordsX_ =
							java.util.Arrays.copyOf(imageFullsegCoordsX_, numUsedInImageFullsegCoordsX_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageFullsegCoordsXList() {
				return java.util.Collections.unmodifiableList(imageFullsegCoordsXArray2list(imageFullsegCoordsX_,
						numUsedInImageFullsegCoordsX_));
			}

			@Override
			public int getImageFullsegCoordsXCount() {
				return numUsedInImageFullsegCoordsX_;
			}

			@Override
			public int getImageFullsegCoordsX(int index) {
				if (index >= numUsedInImageFullsegCoordsX_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageFullsegCoordsX_[index];
			}

			// Note: It is not appropriate to add imageFullsegCoordsX to the returned
			// array because the internal counter numUsedInImageFullsegCoordsX_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageFullsegCoordsXArray() {
				return imageFullsegCoordsX_;
			}

			public Builder setImageFullsegCoordsX(int index, int value) {
				growImageFullsegCoordsXArray();
				imageFullsegCoordsX_[numUsedInImageFullsegCoordsX_] = value;

				return this;
			}

			public Builder addImageFullsegCoordsX(int value) {
				ensureImageFullsegCoordsXIsMutable();
				growImageFullsegCoordsXArray();
				imageFullsegCoordsX_[numUsedInImageFullsegCoordsX_] = value;
				++numUsedInImageFullsegCoordsX_;

				return this;
			}

			public Builder addAllImageFullsegCoordsX(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageFullsegCoordsXIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageFullsegCoordsXArray(growBy);
				for (java.lang.Integer f : values) {
					imageFullsegCoordsX_[numUsedInImageFullsegCoordsX_] = f;
					++numUsedInImageFullsegCoordsX_;
				}

				return this;
			}

			public Builder clearImageFullsegCoordsX() {
				imageFullsegCoordsX_ = null;
				numUsedInImageFullsegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000002);

				return this;
			}

			// repeated int32 image_fullseg_coords_z = 3 [packed = true];
			private int[] imageFullsegCoordsZ_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageFullsegCoordsZ_ = 0;

			public void ensureImageFullsegCoordsZIsMutable() {
				if (!((bitField0_ & 0x00000004) == 0x00000004)) {
					if (imageFullsegCoordsZ_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageFullsegCoordsZ_ = new int[20000];
					}
					bitField0_ |= 0x00000004;
				}
			}

			public void ensureImageFullsegCoordsZIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000004) == 0x00000004)) {
					if (imageFullsegCoordsZ_ == null && initialSize > 0) {
						imageFullsegCoordsZ_ = new int[initialSize];
					}
					bitField0_ |= 0x00000004;
				}
			}

			private void growImageFullsegCoordsZArray() {
				if (imageFullsegCoordsZ_ == null) {
					ensureImageFullsegCoordsZIsMutable();
				} else if (numUsedInImageFullsegCoordsZ_ >= imageFullsegCoordsZ_.length) {
					// Grows our int[] by 20000 elements
					imageFullsegCoordsZ_ =
							java.util.Arrays.copyOf(imageFullsegCoordsZ_, imageFullsegCoordsZ_.length + 20000);
				}
			}

			private void growImageFullsegCoordsZArray(int byAdditional) {
				if (imageFullsegCoordsZ_ == null) {
					ensureImageFullsegCoordsZIsMutable();
				}
				if ((numUsedInImageFullsegCoordsZ_ + byAdditional) >= imageFullsegCoordsZ_.length) {
					imageFullsegCoordsZ_ =
							java.util.Arrays.copyOf(imageFullsegCoordsZ_, numUsedInImageFullsegCoordsZ_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageFullsegCoordsZList() {
				return java.util.Collections.unmodifiableList(imageFullsegCoordsZArray2list(imageFullsegCoordsZ_,
						numUsedInImageFullsegCoordsZ_));
			}

			@Override
			public int getImageFullsegCoordsZCount() {
				return numUsedInImageFullsegCoordsZ_;
			}

			@Override
			public int getImageFullsegCoordsZ(int index) {
				if (index >= numUsedInImageFullsegCoordsZ_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageFullsegCoordsZ_[index];
			}

			// Note: It is not appropriate to add imageFullsegCoordsZ to the returned
			// array because the internal counter numUsedInImageFullsegCoordsZ_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageFullsegCoordsZArray() {
				return imageFullsegCoordsZ_;
			}

			public Builder setImageFullsegCoordsZ(int index, int value) {
				growImageFullsegCoordsZArray();
				imageFullsegCoordsZ_[numUsedInImageFullsegCoordsZ_] = value;

				return this;
			}

			public Builder addImageFullsegCoordsZ(int value) {
				ensureImageFullsegCoordsZIsMutable();
				growImageFullsegCoordsZArray();
				imageFullsegCoordsZ_[numUsedInImageFullsegCoordsZ_] = value;
				++numUsedInImageFullsegCoordsZ_;

				return this;
			}

			public Builder addAllImageFullsegCoordsZ(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageFullsegCoordsZIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageFullsegCoordsZArray(growBy);
				for (java.lang.Integer f : values) {
					imageFullsegCoordsZ_[numUsedInImageFullsegCoordsZ_] = f;
					++numUsedInImageFullsegCoordsZ_;
				}

				return this;
			}

			public Builder clearImageFullsegCoordsZ() {
				imageFullsegCoordsZ_ = null;
				numUsedInImageFullsegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000004);

				return this;
			}

			// repeated int32 image_perimseg_coords_y = 4 [packed = true];
			private int[] imagePerimsegCoordsY_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImagePerimsegCoordsY_ = 0;

			public void ensureImagePerimsegCoordsYIsMutable() {
				if (!((bitField0_ & 0x00000008) == 0x00000008)) {
					if (imagePerimsegCoordsY_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imagePerimsegCoordsY_ = new int[20000];
					}
					bitField0_ |= 0x00000008;
				}
			}

			public void ensureImagePerimsegCoordsYIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000008) == 0x00000008)) {
					if (imagePerimsegCoordsY_ == null && initialSize > 0) {
						imagePerimsegCoordsY_ = new int[initialSize];
					}
					bitField0_ |= 0x00000008;
				}
			}

			private void growImagePerimsegCoordsYArray() {
				if (imagePerimsegCoordsY_ == null) {
					ensureImagePerimsegCoordsYIsMutable();
				} else if (numUsedInImagePerimsegCoordsY_ >= imagePerimsegCoordsY_.length) {
					// Grows our int[] by 20000 elements
					imagePerimsegCoordsY_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsY_, imagePerimsegCoordsY_.length + 20000);
				}
			}

			private void growImagePerimsegCoordsYArray(int byAdditional) {
				if (imagePerimsegCoordsY_ == null) {
					ensureImagePerimsegCoordsYIsMutable();
				}
				if ((numUsedInImagePerimsegCoordsY_ + byAdditional) >= imagePerimsegCoordsY_.length) {
					imagePerimsegCoordsY_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsY_, numUsedInImagePerimsegCoordsY_
									+ byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImagePerimsegCoordsYList() {
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsYArray2list(imagePerimsegCoordsY_,
						numUsedInImagePerimsegCoordsY_));
			}

			@Override
			public int getImagePerimsegCoordsYCount() {
				return numUsedInImagePerimsegCoordsY_;
			}

			@Override
			public int getImagePerimsegCoordsY(int index) {
				if (index >= numUsedInImagePerimsegCoordsY_)
					throw new java.lang.IndexOutOfBoundsException();
				return imagePerimsegCoordsY_[index];
			}

			// Note: It is not appropriate to add imagePerimsegCoordsY to the returned
			// array because the internal counter numUsedInImagePerimsegCoordsY_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImagePerimsegCoordsYArray() {
				return imagePerimsegCoordsY_;
			}

			public Builder setImagePerimsegCoordsY(int index, int value) {
				growImagePerimsegCoordsYArray();
				imagePerimsegCoordsY_[numUsedInImagePerimsegCoordsY_] = value;

				return this;
			}

			public Builder addImagePerimsegCoordsY(int value) {
				ensureImagePerimsegCoordsYIsMutable();
				growImagePerimsegCoordsYArray();
				imagePerimsegCoordsY_[numUsedInImagePerimsegCoordsY_] = value;
				++numUsedInImagePerimsegCoordsY_;

				return this;
			}

			public Builder addAllImagePerimsegCoordsY(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImagePerimsegCoordsYIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImagePerimsegCoordsYArray(growBy);
				for (java.lang.Integer f : values) {
					imagePerimsegCoordsY_[numUsedInImagePerimsegCoordsY_] = f;
					++numUsedInImagePerimsegCoordsY_;
				}

				return this;
			}

			public Builder clearImagePerimsegCoordsY() {
				imagePerimsegCoordsY_ = null;
				numUsedInImagePerimsegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000008);

				return this;
			}

			// repeated int32 image_perimseg_coords_x = 5 [packed = true];
			private int[] imagePerimsegCoordsX_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImagePerimsegCoordsX_ = 0;

			public void ensureImagePerimsegCoordsXIsMutable() {
				if (!((bitField0_ & 0x00000010) == 0x00000010)) {
					if (imagePerimsegCoordsX_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imagePerimsegCoordsX_ = new int[20000];
					}
					bitField0_ |= 0x00000010;
				}
			}

			public void ensureImagePerimsegCoordsXIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000010) == 0x00000010)) {
					if (imagePerimsegCoordsX_ == null && initialSize > 0) {
						imagePerimsegCoordsX_ = new int[initialSize];
					}
					bitField0_ |= 0x00000010;
				}
			}

			private void growImagePerimsegCoordsXArray() {
				if (imagePerimsegCoordsX_ == null) {
					ensureImagePerimsegCoordsXIsMutable();
				} else if (numUsedInImagePerimsegCoordsX_ >= imagePerimsegCoordsX_.length) {
					// Grows our int[] by 20000 elements
					imagePerimsegCoordsX_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsX_, imagePerimsegCoordsX_.length + 20000);
				}
			}

			private void growImagePerimsegCoordsXArray(int byAdditional) {
				if (imagePerimsegCoordsX_ == null) {
					ensureImagePerimsegCoordsXIsMutable();
				}
				if ((numUsedInImagePerimsegCoordsX_ + byAdditional) >= imagePerimsegCoordsX_.length) {
					imagePerimsegCoordsX_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsX_, numUsedInImagePerimsegCoordsX_
									+ byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImagePerimsegCoordsXList() {
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsXArray2list(imagePerimsegCoordsX_,
						numUsedInImagePerimsegCoordsX_));
			}

			@Override
			public int getImagePerimsegCoordsXCount() {
				return numUsedInImagePerimsegCoordsX_;
			}

			@Override
			public int getImagePerimsegCoordsX(int index) {
				if (index >= numUsedInImagePerimsegCoordsX_)
					throw new java.lang.IndexOutOfBoundsException();
				return imagePerimsegCoordsX_[index];
			}

			// Note: It is not appropriate to add imagePerimsegCoordsX to the returned
			// array because the internal counter numUsedInImagePerimsegCoordsX_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImagePerimsegCoordsXArray() {
				return imagePerimsegCoordsX_;
			}

			public Builder setImagePerimsegCoordsX(int index, int value) {
				growImagePerimsegCoordsXArray();
				imagePerimsegCoordsX_[numUsedInImagePerimsegCoordsX_] = value;

				return this;
			}

			public Builder addImagePerimsegCoordsX(int value) {
				ensureImagePerimsegCoordsXIsMutable();
				growImagePerimsegCoordsXArray();
				imagePerimsegCoordsX_[numUsedInImagePerimsegCoordsX_] = value;
				++numUsedInImagePerimsegCoordsX_;

				return this;
			}

			public Builder addAllImagePerimsegCoordsX(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImagePerimsegCoordsXIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImagePerimsegCoordsXArray(growBy);
				for (java.lang.Integer f : values) {
					imagePerimsegCoordsX_[numUsedInImagePerimsegCoordsX_] = f;
					++numUsedInImagePerimsegCoordsX_;
				}

				return this;
			}

			public Builder clearImagePerimsegCoordsX() {
				imagePerimsegCoordsX_ = null;
				numUsedInImagePerimsegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000010);

				return this;
			}

			// repeated int32 image_perimseg_coords_z = 6 [packed = true];
			private int[] imagePerimsegCoordsZ_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImagePerimsegCoordsZ_ = 0;

			public void ensureImagePerimsegCoordsZIsMutable() {
				if (!((bitField0_ & 0x00000020) == 0x00000020)) {
					if (imagePerimsegCoordsZ_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imagePerimsegCoordsZ_ = new int[20000];
					}
					bitField0_ |= 0x00000020;
				}
			}

			public void ensureImagePerimsegCoordsZIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000020) == 0x00000020)) {
					if (imagePerimsegCoordsZ_ == null && initialSize > 0) {
						imagePerimsegCoordsZ_ = new int[initialSize];
					}
					bitField0_ |= 0x00000020;
				}
			}

			private void growImagePerimsegCoordsZArray() {
				if (imagePerimsegCoordsZ_ == null) {
					ensureImagePerimsegCoordsZIsMutable();
				} else if (numUsedInImagePerimsegCoordsZ_ >= imagePerimsegCoordsZ_.length) {
					// Grows our int[] by 20000 elements
					imagePerimsegCoordsZ_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsZ_, imagePerimsegCoordsZ_.length + 20000);
				}
			}

			private void growImagePerimsegCoordsZArray(int byAdditional) {
				if (imagePerimsegCoordsZ_ == null) {
					ensureImagePerimsegCoordsZIsMutable();
				}
				if ((numUsedInImagePerimsegCoordsZ_ + byAdditional) >= imagePerimsegCoordsZ_.length) {
					imagePerimsegCoordsZ_ =
							java.util.Arrays.copyOf(imagePerimsegCoordsZ_, numUsedInImagePerimsegCoordsZ_
									+ byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImagePerimsegCoordsZList() {
				return java.util.Collections.unmodifiableList(imagePerimsegCoordsZArray2list(imagePerimsegCoordsZ_,
						numUsedInImagePerimsegCoordsZ_));
			}

			@Override
			public int getImagePerimsegCoordsZCount() {
				return numUsedInImagePerimsegCoordsZ_;
			}

			@Override
			public int getImagePerimsegCoordsZ(int index) {
				if (index >= numUsedInImagePerimsegCoordsZ_)
					throw new java.lang.IndexOutOfBoundsException();
				return imagePerimsegCoordsZ_[index];
			}

			// Note: It is not appropriate to add imagePerimsegCoordsZ to the returned
			// array because the internal counter numUsedInImagePerimsegCoordsZ_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImagePerimsegCoordsZArray() {
				return imagePerimsegCoordsZ_;
			}

			public Builder setImagePerimsegCoordsZ(int index, int value) {
				growImagePerimsegCoordsZArray();
				imagePerimsegCoordsZ_[numUsedInImagePerimsegCoordsZ_] = value;

				return this;
			}

			public Builder addImagePerimsegCoordsZ(int value) {
				ensureImagePerimsegCoordsZIsMutable();
				growImagePerimsegCoordsZArray();
				imagePerimsegCoordsZ_[numUsedInImagePerimsegCoordsZ_] = value;
				++numUsedInImagePerimsegCoordsZ_;

				return this;
			}

			public Builder addAllImagePerimsegCoordsZ(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImagePerimsegCoordsZIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImagePerimsegCoordsZArray(growBy);
				for (java.lang.Integer f : values) {
					imagePerimsegCoordsZ_[numUsedInImagePerimsegCoordsZ_] = f;
					++numUsedInImagePerimsegCoordsZ_;
				}

				return this;
			}

			public Builder clearImagePerimsegCoordsZ() {
				imagePerimsegCoordsZ_ = null;
				numUsedInImagePerimsegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000020);

				return this;
			}

			// repeated int32 image_userseg_coords_y = 7 [packed = true];
			private int[] imageUsersegCoordsY_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageUsersegCoordsY_ = 0;

			public void ensureImageUsersegCoordsYIsMutable() {
				if (!((bitField0_ & 0x00000040) == 0x00000040)) {
					if (imageUsersegCoordsY_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageUsersegCoordsY_ = new int[20000];
					}
					bitField0_ |= 0x00000040;
				}
			}

			public void ensureImageUsersegCoordsYIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000040) == 0x00000040)) {
					if (imageUsersegCoordsY_ == null && initialSize > 0) {
						imageUsersegCoordsY_ = new int[initialSize];
					}
					bitField0_ |= 0x00000040;
				}
			}

			private void growImageUsersegCoordsYArray() {
				if (imageUsersegCoordsY_ == null) {
					ensureImageUsersegCoordsYIsMutable();
				} else if (numUsedInImageUsersegCoordsY_ >= imageUsersegCoordsY_.length) {
					// Grows our int[] by 20000 elements
					imageUsersegCoordsY_ =
							java.util.Arrays.copyOf(imageUsersegCoordsY_, imageUsersegCoordsY_.length + 20000);
				}
			}

			private void growImageUsersegCoordsYArray(int byAdditional) {
				if (imageUsersegCoordsY_ == null) {
					ensureImageUsersegCoordsYIsMutable();
				}
				if ((numUsedInImageUsersegCoordsY_ + byAdditional) >= imageUsersegCoordsY_.length) {
					imageUsersegCoordsY_ =
							java.util.Arrays.copyOf(imageUsersegCoordsY_, numUsedInImageUsersegCoordsY_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageUsersegCoordsYList() {
				return java.util.Collections.unmodifiableList(imageUsersegCoordsYArray2list(imageUsersegCoordsY_,
						numUsedInImageUsersegCoordsY_));
			}

			@Override
			public int getImageUsersegCoordsYCount() {
				return numUsedInImageUsersegCoordsY_;
			}

			@Override
			public int getImageUsersegCoordsY(int index) {
				if (index >= numUsedInImageUsersegCoordsY_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageUsersegCoordsY_[index];
			}

			// Note: It is not appropriate to add imageUsersegCoordsY to the returned
			// array because the internal counter numUsedInImageUsersegCoordsY_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageUsersegCoordsYArray() {
				return imageUsersegCoordsY_;
			}

			public Builder setImageUsersegCoordsY(int index, int value) {
				growImageUsersegCoordsYArray();
				imageUsersegCoordsY_[numUsedInImageUsersegCoordsY_] = value;

				return this;
			}

			public Builder addImageUsersegCoordsY(int value) {
				ensureImageUsersegCoordsYIsMutable();
				growImageUsersegCoordsYArray();
				imageUsersegCoordsY_[numUsedInImageUsersegCoordsY_] = value;
				++numUsedInImageUsersegCoordsY_;

				return this;
			}

			public Builder addAllImageUsersegCoordsY(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageUsersegCoordsYIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageUsersegCoordsYArray(growBy);
				for (java.lang.Integer f : values) {
					imageUsersegCoordsY_[numUsedInImageUsersegCoordsY_] = f;
					++numUsedInImageUsersegCoordsY_;
				}

				return this;
			}

			public Builder clearImageUsersegCoordsY() {
				imageUsersegCoordsY_ = null;
				numUsedInImageUsersegCoordsY_ = 0;
				bitField0_ = (bitField0_ & ~0x00000040);

				return this;
			}

			// repeated int32 image_userseg_coords_x = 8 [packed = true];
			private int[] imageUsersegCoordsX_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageUsersegCoordsX_ = 0;

			public void ensureImageUsersegCoordsXIsMutable() {
				if (!((bitField0_ & 0x00000080) == 0x00000080)) {
					if (imageUsersegCoordsX_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageUsersegCoordsX_ = new int[20000];
					}
					bitField0_ |= 0x00000080;
				}
			}

			public void ensureImageUsersegCoordsXIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000080) == 0x00000080)) {
					if (imageUsersegCoordsX_ == null && initialSize > 0) {
						imageUsersegCoordsX_ = new int[initialSize];
					}
					bitField0_ |= 0x00000080;
				}
			}

			private void growImageUsersegCoordsXArray() {
				if (imageUsersegCoordsX_ == null) {
					ensureImageUsersegCoordsXIsMutable();
				} else if (numUsedInImageUsersegCoordsX_ >= imageUsersegCoordsX_.length) {
					// Grows our int[] by 20000 elements
					imageUsersegCoordsX_ =
							java.util.Arrays.copyOf(imageUsersegCoordsX_, imageUsersegCoordsX_.length + 20000);
				}
			}

			private void growImageUsersegCoordsXArray(int byAdditional) {
				if (imageUsersegCoordsX_ == null) {
					ensureImageUsersegCoordsXIsMutable();
				}
				if ((numUsedInImageUsersegCoordsX_ + byAdditional) >= imageUsersegCoordsX_.length) {
					imageUsersegCoordsX_ =
							java.util.Arrays.copyOf(imageUsersegCoordsX_, numUsedInImageUsersegCoordsX_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageUsersegCoordsXList() {
				return java.util.Collections.unmodifiableList(imageUsersegCoordsXArray2list(imageUsersegCoordsX_,
						numUsedInImageUsersegCoordsX_));
			}

			@Override
			public int getImageUsersegCoordsXCount() {
				return numUsedInImageUsersegCoordsX_;
			}

			@Override
			public int getImageUsersegCoordsX(int index) {
				if (index >= numUsedInImageUsersegCoordsX_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageUsersegCoordsX_[index];
			}

			// Note: It is not appropriate to add imageUsersegCoordsX to the returned
			// array because the internal counter numUsedInImageUsersegCoordsX_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageUsersegCoordsXArray() {
				return imageUsersegCoordsX_;
			}

			public Builder setImageUsersegCoordsX(int index, int value) {
				growImageUsersegCoordsXArray();
				imageUsersegCoordsX_[numUsedInImageUsersegCoordsX_] = value;

				return this;
			}

			public Builder addImageUsersegCoordsX(int value) {
				ensureImageUsersegCoordsXIsMutable();
				growImageUsersegCoordsXArray();
				imageUsersegCoordsX_[numUsedInImageUsersegCoordsX_] = value;
				++numUsedInImageUsersegCoordsX_;

				return this;
			}

			public Builder addAllImageUsersegCoordsX(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageUsersegCoordsXIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageUsersegCoordsXArray(growBy);
				for (java.lang.Integer f : values) {
					imageUsersegCoordsX_[numUsedInImageUsersegCoordsX_] = f;
					++numUsedInImageUsersegCoordsX_;
				}

				return this;
			}

			public Builder clearImageUsersegCoordsX() {
				imageUsersegCoordsX_ = null;
				numUsedInImageUsersegCoordsX_ = 0;
				bitField0_ = (bitField0_ & ~0x00000080);

				return this;
			}

			// repeated int32 image_userseg_coords_z = 9 [packed = true];
			private int[] imageUsersegCoordsZ_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInImageUsersegCoordsZ_ = 0;

			public void ensureImageUsersegCoordsZIsMutable() {
				if (!((bitField0_ & 0x00000100) == 0x00000100)) {
					if (imageUsersegCoordsZ_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						imageUsersegCoordsZ_ = new int[20000];
					}
					bitField0_ |= 0x00000100;
				}
			}

			public void ensureImageUsersegCoordsZIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000100) == 0x00000100)) {
					if (imageUsersegCoordsZ_ == null && initialSize > 0) {
						imageUsersegCoordsZ_ = new int[initialSize];
					}
					bitField0_ |= 0x00000100;
				}
			}

			private void growImageUsersegCoordsZArray() {
				if (imageUsersegCoordsZ_ == null) {
					ensureImageUsersegCoordsZIsMutable();
				} else if (numUsedInImageUsersegCoordsZ_ >= imageUsersegCoordsZ_.length) {
					// Grows our int[] by 20000 elements
					imageUsersegCoordsZ_ =
							java.util.Arrays.copyOf(imageUsersegCoordsZ_, imageUsersegCoordsZ_.length + 20000);
				}
			}

			private void growImageUsersegCoordsZArray(int byAdditional) {
				if (imageUsersegCoordsZ_ == null) {
					ensureImageUsersegCoordsZIsMutable();
				}
				if ((numUsedInImageUsersegCoordsZ_ + byAdditional) >= imageUsersegCoordsZ_.length) {
					imageUsersegCoordsZ_ =
							java.util.Arrays.copyOf(imageUsersegCoordsZ_, numUsedInImageUsersegCoordsZ_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Integer> getImageUsersegCoordsZList() {
				return java.util.Collections.unmodifiableList(imageUsersegCoordsZArray2list(imageUsersegCoordsZ_,
						numUsedInImageUsersegCoordsZ_));
			}

			@Override
			public int getImageUsersegCoordsZCount() {
				return numUsedInImageUsersegCoordsZ_;
			}

			@Override
			public int getImageUsersegCoordsZ(int index) {
				if (index >= numUsedInImageUsersegCoordsZ_)
					throw new java.lang.IndexOutOfBoundsException();
				return imageUsersegCoordsZ_[index];
			}

			// Note: It is not appropriate to add imageUsersegCoordsZ to the returned
			// array because the internal counter numUsedInImageUsersegCoordsZ_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public int[] getImageUsersegCoordsZArray() {
				return imageUsersegCoordsZ_;
			}

			public Builder setImageUsersegCoordsZ(int index, int value) {
				growImageUsersegCoordsZArray();
				imageUsersegCoordsZ_[numUsedInImageUsersegCoordsZ_] = value;

				return this;
			}

			public Builder addImageUsersegCoordsZ(int value) {
				ensureImageUsersegCoordsZIsMutable();
				growImageUsersegCoordsZArray();
				imageUsersegCoordsZ_[numUsedInImageUsersegCoordsZ_] = value;
				++numUsedInImageUsersegCoordsZ_;

				return this;
			}

			public Builder addAllImageUsersegCoordsZ(java.lang.Iterable<? extends java.lang.Integer> values) {
				ensureImageUsersegCoordsZIsMutable();
				int growBy = 0;
				for (java.lang.Integer f : values)
					++growBy;
				growImageUsersegCoordsZArray(growBy);
				for (java.lang.Integer f : values) {
					imageUsersegCoordsZ_[numUsedInImageUsersegCoordsZ_] = f;
					++numUsedInImageUsersegCoordsZ_;
				}

				return this;
			}

			public Builder clearImageUsersegCoordsZ() {
				imageUsersegCoordsZ_ = null;
				numUsedInImageUsersegCoordsZ_ = 0;
				bitField0_ = (bitField0_ & ~0x00000100);

				return this;
			}

			// repeated float quantifiedProperties = 10;
			private float[] quantifiedProperties_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInQuantifiedProperties_ = 0;

			public void ensureQuantifiedPropertiesIsMutable() {
				if (!((bitField0_ & 0x00000200) == 0x00000200)) {
					if (quantifiedProperties_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						quantifiedProperties_ = new float[20000];
					}
					bitField0_ |= 0x00000200;
				}
			}

			public void ensureQuantifiedPropertiesIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000200) == 0x00000200)) {
					if (quantifiedProperties_ == null && initialSize > 0) {
						quantifiedProperties_ = new float[initialSize];
					}
					bitField0_ |= 0x00000200;
				}
			}

			private void growQuantifiedPropertiesArray() {
				if (quantifiedProperties_ == null) {
					ensureQuantifiedPropertiesIsMutable();
				} else if (numUsedInQuantifiedProperties_ >= quantifiedProperties_.length) {
					// Grows our float[] by 20000 elements
					quantifiedProperties_ =
							java.util.Arrays.copyOf(quantifiedProperties_, quantifiedProperties_.length + 20000);
				}
			}

			private void growQuantifiedPropertiesArray(int byAdditional) {
				if (quantifiedProperties_ == null) {
					ensureQuantifiedPropertiesIsMutable();
				}
				if ((numUsedInQuantifiedProperties_ + byAdditional) >= quantifiedProperties_.length) {
					quantifiedProperties_ =
							java.util.Arrays.copyOf(quantifiedProperties_, numUsedInQuantifiedProperties_
									+ byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Float> getQuantifiedPropertiesList() {
				return java.util.Collections.unmodifiableList(quantifiedPropertiesArray2list(quantifiedProperties_,
						numUsedInQuantifiedProperties_));
			}

			@Override
			public int getQuantifiedPropertiesCount() {
				return numUsedInQuantifiedProperties_;
			}

			@Override
			public float getQuantifiedProperties(int index) {
				if (index >= numUsedInQuantifiedProperties_)
					throw new java.lang.IndexOutOfBoundsException();
				return quantifiedProperties_[index];
			}

			// Note: It is not appropriate to add quantifiedProperties to the returned
			// array because the internal counter numUsedInQuantifiedProperties_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public float[] getQuantifiedPropertiesArray() {
				return quantifiedProperties_;
			}

			public Builder setQuantifiedProperties(int index, float value) {
				growQuantifiedPropertiesArray();
				quantifiedProperties_[numUsedInQuantifiedProperties_] = value;

				return this;
			}

			public Builder addQuantifiedProperties(float value) {
				ensureQuantifiedPropertiesIsMutable();
				growQuantifiedPropertiesArray();
				quantifiedProperties_[numUsedInQuantifiedProperties_] = value;
				++numUsedInQuantifiedProperties_;

				return this;
			}

			public Builder addAllQuantifiedProperties(java.lang.Iterable<? extends java.lang.Float> values) {
				ensureQuantifiedPropertiesIsMutable();
				int growBy = 0;
				for (java.lang.Float f : values)
					++growBy;
				growQuantifiedPropertiesArray(growBy);
				for (java.lang.Float f : values) {
					quantifiedProperties_[numUsedInQuantifiedProperties_] = f;
					++numUsedInQuantifiedProperties_;
				}

				return this;
			}

			public Builder clearQuantifiedProperties() {
				quantifiedProperties_ = null;
				numUsedInQuantifiedProperties_ = 0;
				bitField0_ = (bitField0_ & ~0x00000200);

				return this;
			}

			// repeated float userCellValue = 11;
			private float[] userCellValue_ = null;
			// transient just a hint that this isn't really a piece of data
			public transient int numUsedInUserCellValue_ = 0;

			public void ensureUserCellValueIsMutable() {
				if (!((bitField0_ & 0x00000400) == 0x00000400)) {
					if (userCellValue_ == null) {
						// This field will be grown by blocks of 20000 (that may require some
						// tweaking or an ability to be parameterized via metadata of some sort
						// Let's also start off with 20000 elements
						userCellValue_ = new float[20000];
					}
					bitField0_ |= 0x00000400;
				}
			}

			public void ensureUserCellValueIsMutable(int initialSize) {
				if (!((bitField0_ & 0x00000400) == 0x00000400)) {
					if (userCellValue_ == null && initialSize > 0) {
						userCellValue_ = new float[initialSize];
					}
					bitField0_ |= 0x00000400;
				}
			}

			private void growUserCellValueArray() {
				if (userCellValue_ == null) {
					ensureUserCellValueIsMutable();
				} else if (numUsedInUserCellValue_ >= userCellValue_.length) {
					// Grows our float[] by 20000 elements
					userCellValue_ = java.util.Arrays.copyOf(userCellValue_, userCellValue_.length + 20000);
				}
			}

			private void growUserCellValueArray(int byAdditional) {
				if (userCellValue_ == null) {
					ensureUserCellValueIsMutable();
				}
				if ((numUsedInUserCellValue_ + byAdditional) >= userCellValue_.length) {
					userCellValue_ = java.util.Arrays.copyOf(userCellValue_, numUsedInUserCellValue_ + byAdditional);
				}
			}

			@Override
			public java.util.List<java.lang.Float> getUserCellValueList() {
				return java.util.Collections.unmodifiableList(userCellValueArray2list(userCellValue_,
						numUsedInUserCellValue_));
			}

			@Override
			public int getUserCellValueCount() {
				return numUsedInUserCellValue_;
			}

			@Override
			public float getUserCellValue(int index) {
				if (index >= numUsedInUserCellValue_)
					throw new java.lang.IndexOutOfBoundsException();
				return userCellValue_[index];
			}

			// Note: It is not appropriate to add userCellValue to the returned
			// array because the internal counter numUsedInUserCellValue_ will
			// not be incremented properly!! Additionally, if used
			// as an Accessor only the getDataCount() number of
			// values are valid!
			public float[] getUserCellValueArray() {
				return userCellValue_;
			}

			public Builder setUserCellValue(int index, float value) {
				growUserCellValueArray();
				userCellValue_[numUsedInUserCellValue_] = value;

				return this;
			}

			public Builder addUserCellValue(float value) {
				ensureUserCellValueIsMutable();
				growUserCellValueArray();
				userCellValue_[numUsedInUserCellValue_] = value;
				++numUsedInUserCellValue_;

				return this;
			}

			public Builder addAllUserCellValue(java.lang.Iterable<? extends java.lang.Float> values) {
				ensureUserCellValueIsMutable();
				int growBy = 0;
				for (java.lang.Float f : values)
					++growBy;
				growUserCellValueArray(growBy);
				for (java.lang.Float f : values) {
					userCellValue_[numUsedInUserCellValue_] = f;
					++numUsedInUserCellValue_;
				}

				return this;
			}

			public Builder clearUserCellValue() {
				userCellValue_ = null;
				numUsedInUserCellValue_ = 0;
				bitField0_ = (bitField0_ & ~0x00000400);

				return this;
			}

			// repeated string userCellFormula = 12;
			private com.google.protobuf.LazyStringList userCellFormula_ = com.google.protobuf.LazyStringArrayList.EMPTY;

			public void ensureUserCellFormulaIsMutable() {
				if (!((bitField0_ & 0x00000800) == 0x00000800)) {
					userCellFormula_ = new com.google.protobuf.LazyStringArrayList(userCellFormula_);
					bitField0_ |= 0x00000800;
				}
			}

			@Override
			public java.util.List<String> getUserCellFormulaList() {
				return java.util.Collections.unmodifiableList(userCellFormula_);
			}

			@Override
			public int getUserCellFormulaCount() {
				return userCellFormula_.size();
			}

			@Override
			public String getUserCellFormula(int index) {
				return userCellFormula_.get(index);
			}

			public Builder setUserCellFormula(int index, String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureUserCellFormulaIsMutable();
				userCellFormula_.set(index, value);

				return this;
			}

			public Builder addUserCellFormula(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureUserCellFormulaIsMutable();
				userCellFormula_.add(value);

				return this;
			}

			public Builder addAllUserCellFormula(java.lang.Iterable<String> values) {
				ensureUserCellFormulaIsMutable();
				super.addAll(values, userCellFormula_);

				return this;
			}

			public Builder clearUserCellFormula() {
				userCellFormula_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000800);

				return this;
			}

			void addUserCellFormula(com.google.protobuf.ByteString value) {
				ensureUserCellFormulaIsMutable();
				userCellFormula_.add(value);

			}

			// optional float idx = 13;
			private float idx_;

			@Override
			public boolean hasIdx() {
				return ((bitField0_ & 0x00001000) == 0x00001000);
			}

			@Override
			public float getIdx() {
				return idx_;
			}

			public Builder setIdx(float value) {
				bitField0_ |= 0x00001000;
				idx_ = value;

				return this;
			}

			public Builder clearIdx() {
				bitField0_ = (bitField0_ & ~0x00001000);
				idx_ = 0F;

				return this;
			}

			// optional float seed_y = 14;
			private float seedY_;

			@Override
			public boolean hasSeedY() {
				return ((bitField0_ & 0x00002000) == 0x00002000);
			}

			@Override
			public float getSeedY() {
				return seedY_;
			}

			public Builder setSeedY(float value) {
				bitField0_ |= 0x00002000;
				seedY_ = value;

				return this;
			}

			public Builder clearSeedY() {
				bitField0_ = (bitField0_ & ~0x00002000);
				seedY_ = 0F;

				return this;
			}

			// optional float seed_x = 15;
			private float seedX_;

			@Override
			public boolean hasSeedX() {
				return ((bitField0_ & 0x00004000) == 0x00004000);
			}

			@Override
			public float getSeedX() {
				return seedX_;
			}

			public Builder setSeedX(float value) {
				bitField0_ |= 0x00004000;
				seedX_ = value;

				return this;
			}

			public Builder clearSeedX() {
				bitField0_ = (bitField0_ & ~0x00004000);
				seedX_ = 0F;

				return this;
			}

			// optional float seed_z = 16;
			private float seedZ_;

			@Override
			public boolean hasSeedZ() {
				return ((bitField0_ & 0x00008000) == 0x00008000);
			}

			@Override
			public float getSeedZ() {
				return seedZ_;
			}

			public Builder setSeedZ(float value) {
				bitField0_ |= 0x00008000;
				seedZ_ = value;

				return this;
			}

			public Builder clearSeedZ() {
				bitField0_ = (bitField0_ & ~0x00008000);
				seedZ_ = 0F;

				return this;
			}

			// optional float seed_manual = 17;
			private float seedManual_;

			@Override
			public boolean hasSeedManual() {
				return ((bitField0_ & 0x00010000) == 0x00010000);
			}

			@Override
			public float getSeedManual() {
				return seedManual_;
			}

			public Builder setSeedManual(float value) {
				bitField0_ |= 0x00010000;
				seedManual_ = value;

				return this;
			}

			public Builder clearSeedManual() {
				bitField0_ = (bitField0_ & ~0x00010000);
				seedManual_ = 0F;

				return this;
			}

			// optional float contour_AddRemoveMerge = 18;
			private float contourAddRemoveMerge_;

			@Override
			public boolean hasContourAddRemoveMerge() {
				return ((bitField0_ & 0x00020000) == 0x00020000);
			}

			@Override
			public float getContourAddRemoveMerge() {
				return contourAddRemoveMerge_;
			}

			public Builder setContourAddRemoveMerge(float value) {
				bitField0_ |= 0x00020000;
				contourAddRemoveMerge_ = value;

				return this;
			}

			public Builder clearContourAddRemoveMerge() {
				bitField0_ = (bitField0_ & ~0x00020000);
				contourAddRemoveMerge_ = 0F;

				return this;
			}

			// optional float contour_MergeGroup = 19;
			private float contourMergeGroup_;

			@Override
			public boolean hasContourMergeGroup() {
				return ((bitField0_ & 0x00040000) == 0x00040000);
			}

			@Override
			public float getContourMergeGroup() {
				return contourMergeGroup_;
			}

			public Builder setContourMergeGroup(float value) {
				bitField0_ |= 0x00040000;
				contourMergeGroup_ = value;

				return this;
			}

			public Builder clearContourMergeGroup() {
				bitField0_ = (bitField0_ & ~0x00040000);
				contourMergeGroup_ = 0F;

				return this;
			}

			// optional float contour_WindowSize = 20;
			private float contourWindowSize_;

			@Override
			public boolean hasContourWindowSize() {
				return ((bitField0_ & 0x00080000) == 0x00080000);
			}

			@Override
			public float getContourWindowSize() {
				return contourWindowSize_;
			}

			public Builder setContourWindowSize(float value) {
				bitField0_ |= 0x00080000;
				contourWindowSize_ = value;

				return this;
			}

			public Builder clearContourWindowSize() {
				bitField0_ = (bitField0_ & ~0x00080000);
				contourWindowSize_ = 0F;

				return this;
			}

			// optional float contour_Tmax = 21;
			private float contourTmax_;

			@Override
			public boolean hasContourTmax() {
				return ((bitField0_ & 0x00100000) == 0x00100000);
			}

			@Override
			public float getContourTmax() {
				return contourTmax_;
			}

			public Builder setContourTmax(float value) {
				bitField0_ |= 0x00100000;
				contourTmax_ = value;

				return this;
			}

			public Builder clearContourTmax() {
				bitField0_ = (bitField0_ & ~0x00100000);
				contourTmax_ = 0F;

				return this;
			}

			// optional float contour_segmethod = 22;
			private float contourSegmethod_;

			@Override
			public boolean hasContourSegmethod() {
				return ((bitField0_ & 0x00200000) == 0x00200000);
			}

			@Override
			public float getContourSegmethod() {
				return contourSegmethod_;
			}

			public Builder setContourSegmethod(float value) {
				bitField0_ |= 0x00200000;
				contourSegmethod_ = value;

				return this;
			}

			public Builder clearContourSegmethod() {
				bitField0_ = (bitField0_ & ~0x00200000);
				contourSegmethod_ = 0F;

				return this;
			}

			// optional float hand_validated = 23 [default = 1];
			private float handValidated_ = 1F;

			@Override
			public boolean hasHandValidated() {
				return ((bitField0_ & 0x00400000) == 0x00400000);
			}

			@Override
			public float getHandValidated() {
				return handValidated_;
			}

			public Builder setHandValidated(float value) {
				bitField0_ |= 0x00400000;
				handValidated_ = value;

				return this;
			}

			public Builder clearHandValidated() {
				bitField0_ = (bitField0_ & ~0x00400000);
				handValidated_ = 1F;

				return this;
			}

			// optional float seed_hsz = 24;
			private float seedHsz_;

			@Override
			public boolean hasSeedHsz() {
				return ((bitField0_ & 0x00800000) == 0x00800000);
			}

			@Override
			public float getSeedHsz() {
				return seedHsz_;
			}

			public Builder setSeedHsz(float value) {
				bitField0_ |= 0x00800000;
				seedHsz_ = value;

				return this;
			}

			public Builder clearSeedHsz() {
				bitField0_ = (bitField0_ & ~0x00800000);
				seedHsz_ = 0F;

				return this;
			}

			// optional float seed_t1 = 25;
			private float seedT1_;

			@Override
			public boolean hasSeedT1() {
				return ((bitField0_ & 0x01000000) == 0x01000000);
			}

			@Override
			public float getSeedT1() {
				return seedT1_;
			}

			public Builder setSeedT1(float value) {
				bitField0_ |= 0x01000000;
				seedT1_ = value;

				return this;
			}

			public Builder clearSeedT1() {
				bitField0_ = (bitField0_ & ~0x01000000);
				seedT1_ = 0F;

				return this;
			}

			// optional float seed_t2 = 26;
			private float seedT2_;

			@Override
			public boolean hasSeedT2() {
				return ((bitField0_ & 0x02000000) == 0x02000000);
			}

			@Override
			public float getSeedT2() {
				return seedT2_;
			}

			public Builder setSeedT2(float value) {
				bitField0_ |= 0x02000000;
				seedT2_ = value;

				return this;
			}

			public Builder clearSeedT2() {
				bitField0_ = (bitField0_ & ~0x02000000);
				seedT2_ = 0F;

				return this;
			}

			// optional float seed_segmethod = 27;
			private float seedSegmethod_;

			@Override
			public boolean hasSeedSegmethod() {
				return ((bitField0_ & 0x04000000) == 0x04000000);
			}

			@Override
			public float getSeedSegmethod() {
				return seedSegmethod_;
			}

			public Builder setSeedSegmethod(float value) {
				bitField0_ |= 0x04000000;
				seedSegmethod_ = value;

				return this;
			}

			public Builder clearSeedSegmethod() {
				bitField0_ = (bitField0_ & ~0x04000000);
				seedSegmethod_ = 0F;

				return this;
			}

			// @@protoc_insertion_point(builder_scope:protobuf_package.SegInfo)
		}

		static {
			defaultInstance = new SegInfo(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:protobuf_package.SegInfo)
	}

	public interface SegDirectoryOrBuilder extends com.google.protobuf.MessageLiteOrBuilder {

		// repeated .protobuf_package.SegInfo protobuf_info = 1;
		java.util.List<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> getProtobufInfoList();

		pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo getProtobufInfo(int index);

		int getProtobufInfoCount();

		// repeated string userCellDescriptions = 2;
		java.util.List<String> getUserCellDescriptionsList();

		int getUserCellDescriptionsCount();

		String getUserCellDescriptions(int index);

		// repeated string quantifiedPropertyNames = 3;
		java.util.List<String> getQuantifiedPropertyNamesList();

		int getQuantifiedPropertyNamesCount();

		String getQuantifiedPropertyNames(int index);

		// optional float idx_max = 4 [default = 0];
		boolean hasIdxMax();

		float getIdxMax();

		// optional float image_dimy = 5;
		boolean hasImageDimy();

		float getImageDimy();

		// optional float image_dimx = 6;
		boolean hasImageDimx();

		float getImageDimx();

		// optional float image_dimz = 7;
		boolean hasImageDimz();

		float getImageDimz();

		// optional float x_micron_calibration = 8;
		boolean hasXMicronCalibration();

		float getXMicronCalibration();

		// optional float y_micron_calibration = 9;
		boolean hasYMicronCalibration();

		float getYMicronCalibration();

		// optional float z_micron_calibration = 10;
		boolean hasZMicronCalibration();

		float getZMicronCalibration();
	}

	public static final class SegDirectory extends com.google.protobuf.GeneratedMessageLite implements
			SegDirectoryOrBuilder {
		// Use SegDirectory.newBuilder() to construct.
		private SegDirectory(Builder builder) {
			super(builder);
		}

		private SegDirectory(boolean noInit) {
		}

		private static final SegDirectory defaultInstance;

		public static SegDirectory getDefaultInstance() {
			return defaultInstance;
		}

		@Override
		public SegDirectory getDefaultInstanceForType() {
			return defaultInstance;
		}

		private int bitField0_;
		// repeated .protobuf_package.SegInfo protobuf_info = 1;
		public static final int PROTOBUF_INFO_FIELD_NUMBER = 1;
		private java.util.List<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> protobufInfo_;

		@Override
		public java.util.List<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> getProtobufInfoList() {
			return protobufInfo_;
		}

		public java.util.List<? extends pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfoOrBuilder>
				getProtobufInfoOrBuilderList() {
			return protobufInfo_;
		}

		@Override
		public int getProtobufInfoCount() {
			return protobufInfo_.size();
		}

		@Override
		public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo getProtobufInfo(int index) {
			return protobufInfo_.get(index);
		}

		public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfoOrBuilder getProtobufInfoOrBuilder(int index) {
			return protobufInfo_.get(index);
		}

		// repeated string userCellDescriptions = 2;
		public static final int USERCELLDESCRIPTIONS_FIELD_NUMBER = 2;
		private com.google.protobuf.LazyStringList userCellDescriptions_;

		@Override
		public java.util.List<String> getUserCellDescriptionsList() {
			return userCellDescriptions_;
		}

		@Override
		public int getUserCellDescriptionsCount() {
			return userCellDescriptions_.size();
		}

		@Override
		public String getUserCellDescriptions(int index) {
			return userCellDescriptions_.get(index);
		}

		// repeated string quantifiedPropertyNames = 3;
		public static final int QUANTIFIEDPROPERTYNAMES_FIELD_NUMBER = 3;
		private com.google.protobuf.LazyStringList quantifiedPropertyNames_;

		@Override
		public java.util.List<String> getQuantifiedPropertyNamesList() {
			return quantifiedPropertyNames_;
		}

		@Override
		public int getQuantifiedPropertyNamesCount() {
			return quantifiedPropertyNames_.size();
		}

		@Override
		public String getQuantifiedPropertyNames(int index) {
			return quantifiedPropertyNames_.get(index);
		}

		// optional float idx_max = 4 [default = 0];
		public static final int IDX_MAX_FIELD_NUMBER = 4;
		private float idxMax_;

		@Override
		public boolean hasIdxMax() {
			return ((bitField0_ & 0x00000001) == 0x00000001);
		}

		@Override
		public float getIdxMax() {
			return idxMax_;
		}

		// optional float image_dimy = 5;
		public static final int IMAGE_DIMY_FIELD_NUMBER = 5;
		private float imageDimy_;

		@Override
		public boolean hasImageDimy() {
			return ((bitField0_ & 0x00000002) == 0x00000002);
		}

		@Override
		public float getImageDimy() {
			return imageDimy_;
		}

		// optional float image_dimx = 6;
		public static final int IMAGE_DIMX_FIELD_NUMBER = 6;
		private float imageDimx_;

		@Override
		public boolean hasImageDimx() {
			return ((bitField0_ & 0x00000004) == 0x00000004);
		}

		@Override
		public float getImageDimx() {
			return imageDimx_;
		}

		// optional float image_dimz = 7;
		public static final int IMAGE_DIMZ_FIELD_NUMBER = 7;
		private float imageDimz_;

		@Override
		public boolean hasImageDimz() {
			return ((bitField0_ & 0x00000008) == 0x00000008);
		}

		@Override
		public float getImageDimz() {
			return imageDimz_;
		}

		// optional float x_micron_calibration = 8;
		public static final int X_MICRON_CALIBRATION_FIELD_NUMBER = 8;
		private float xMicronCalibration_;

		@Override
		public boolean hasXMicronCalibration() {
			return ((bitField0_ & 0x00000010) == 0x00000010);
		}

		@Override
		public float getXMicronCalibration() {
			return xMicronCalibration_;
		}

		// optional float y_micron_calibration = 9;
		public static final int Y_MICRON_CALIBRATION_FIELD_NUMBER = 9;
		private float yMicronCalibration_;

		@Override
		public boolean hasYMicronCalibration() {
			return ((bitField0_ & 0x00000020) == 0x00000020);
		}

		@Override
		public float getYMicronCalibration() {
			return yMicronCalibration_;
		}

		// optional float z_micron_calibration = 10;
		public static final int Z_MICRON_CALIBRATION_FIELD_NUMBER = 10;
		private float zMicronCalibration_;

		@Override
		public boolean hasZMicronCalibration() {
			return ((bitField0_ & 0x00000040) == 0x00000040);
		}

		@Override
		public float getZMicronCalibration() {
			return zMicronCalibration_;
		}

		private void initFields() {
			protobufInfo_ = java.util.Collections.emptyList();
			userCellDescriptions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
			quantifiedPropertyNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
			idxMax_ = 0F;
			imageDimy_ = 0F;
			imageDimx_ = 0F;
			imageDimz_ = 0F;
			xMicronCalibration_ = 0F;
			yMicronCalibration_ = 0F;
			zMicronCalibration_ = 0F;
		}

		private byte memoizedIsInitialized = -1;

		@Override
		public final boolean isInitialized() {
			byte isInitialized = memoizedIsInitialized;
			if (isInitialized != -1)
				return isInitialized == 1;

			memoizedIsInitialized = 1;
			return true;
		}

		@Override
		public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
			getSerializedSize();
			for (int i = 0; i < protobufInfo_.size(); i++) {
				output.writeMessage(1, protobufInfo_.get(i));
			}
			for (int i = 0; i < userCellDescriptions_.size(); i++) {
				output.writeBytes(2, userCellDescriptions_.getByteString(i));
			}
			for (int i = 0; i < quantifiedPropertyNames_.size(); i++) {
				output.writeBytes(3, quantifiedPropertyNames_.getByteString(i));
			}
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				output.writeFloat(4, idxMax_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				output.writeFloat(5, imageDimy_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				output.writeFloat(6, imageDimx_);
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				output.writeFloat(7, imageDimz_);
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				output.writeFloat(8, xMicronCalibration_);
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				output.writeFloat(9, yMicronCalibration_);
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				output.writeFloat(10, zMicronCalibration_);
			}
		}

		private int memoizedSerializedSize = -1;

		@Override
		public int getSerializedSize() {
			int size = memoizedSerializedSize;
			if (size != -1)
				return size;

			size = 0;
			for (int i = 0; i < protobufInfo_.size(); i++) {
				size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, protobufInfo_.get(i));
			}
			{
				int dataSize = 0;
				for (int i = 0; i < userCellDescriptions_.size(); i++) {
					dataSize +=
							com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(userCellDescriptions_
									.getByteString(i));
				}
				size += dataSize;
				size += 1 * getUserCellDescriptionsList().size();
			}
			{
				int dataSize = 0;
				for (int i = 0; i < quantifiedPropertyNames_.size(); i++) {
					dataSize +=
							com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(quantifiedPropertyNames_
									.getByteString(i));
				}
				size += dataSize;
				size += 1 * getQuantifiedPropertyNamesList().size();
			}
			if (((bitField0_ & 0x00000001) == 0x00000001)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(4, idxMax_);
			}
			if (((bitField0_ & 0x00000002) == 0x00000002)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(5, imageDimy_);
			}
			if (((bitField0_ & 0x00000004) == 0x00000004)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(6, imageDimx_);
			}
			if (((bitField0_ & 0x00000008) == 0x00000008)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(7, imageDimz_);
			}
			if (((bitField0_ & 0x00000010) == 0x00000010)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(8, xMicronCalibration_);
			}
			if (((bitField0_ & 0x00000020) == 0x00000020)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(9, yMicronCalibration_);
			}
			if (((bitField0_ & 0x00000040) == 0x00000040)) {
				size += com.google.protobuf.CodedOutputStream.computeFloatSize(10, zMicronCalibration_);
			}
			memoizedSerializedSize = size;
			return size;
		}

		private static final long serialVersionUID = 0L;

		@java.lang.Override
		protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
			return super.writeReplace();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(
				com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(
				com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(byte[] data)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(byte[] data,
				com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws com.google.protobuf.InvalidProtocolBufferException {
			return newBuilder().mergeFrom(data, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(java.io.InputStream input)
				throws java.io.IOException {
			return newBuilder().mergeFrom(input).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(java.io.InputStream input,
				com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return newBuilder().mergeFrom(input, extensionRegistry).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseDelimitedFrom(
				java.io.InputStream input) throws java.io.IOException {
			Builder builder = newBuilder();
			if (builder.mergeDelimitedFrom(input)) {
				return builder.buildParsed();
			} else {
				return null;
			}
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseDelimitedFrom(
				java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
				throws java.io.IOException {
			Builder builder = newBuilder();
			if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
				return builder.buildParsed();
			} else {
				return null;
			}
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory parseFrom(
				com.google.protobuf.CodedInputStream input) throws java.io.IOException {
			return newBuilder().mergeFrom(input).buildParsed();
		}

		public static pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory
				parseFrom(com.google.protobuf.CodedInputStream input,
						com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			return newBuilder().mergeFrom(input, extensionRegistry).buildParsed();
		}

		public static Builder newBuilder() {
			return Builder.create();
		}

		@Override
		public Builder newBuilderForType() {
			return newBuilder();
		}

		public static Builder newBuilder(pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory prototype) {
			return newBuilder().mergeFrom(prototype);
		}

		@Override
		public Builder toBuilder() {
			return newBuilder(this);
		}

		public static final class Builder
				extends
				com.google.protobuf.GeneratedMessageLite.Builder<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory, Builder>
				implements pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectoryOrBuilder {
			// Construct using pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory.newBuilder()
			private Builder() {
				maybeForceBuilderInitialization();
			}

			private void maybeForceBuilderInitialization() {
			}

			private static Builder create() {
				return new Builder();
			}

			@Override
			public Builder clear() {
				super.clear();
				protobufInfo_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000001);
				userCellDescriptions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000002);
				quantifiedPropertyNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000004);
				idxMax_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000008);
				imageDimy_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000010);
				imageDimx_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000020);
				imageDimz_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000040);
				xMicronCalibration_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000080);
				yMicronCalibration_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000100);
				zMicronCalibration_ = 0F;
				bitField0_ = (bitField0_ & ~0x00000200);
				return this;
			}

			@Override
			public Builder clone() {
				return create().mergeFrom(buildPartial());
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory getDefaultInstanceForType() {
				return pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory.getDefaultInstance();
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory build() {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result);
				}
				return result;
			}

			private pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory buildParsed()
					throws com.google.protobuf.InvalidProtocolBufferException {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory result = buildPartial();
				if (!result.isInitialized()) {
					throw newUninitializedMessageException(result).asInvalidProtocolBufferException();
				}
				return result;
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory buildPartial() {
				pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory result =
						new pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory(this);
				int from_bitField0_ = bitField0_;
				int to_bitField0_ = 0;
				if (((bitField0_ & 0x00000001) == 0x00000001)) {
					protobufInfo_ = java.util.Collections.unmodifiableList(protobufInfo_);
					bitField0_ = (bitField0_ & ~0x00000001);
				}
				result.protobufInfo_ = protobufInfo_;
				if (((bitField0_ & 0x00000002) == 0x00000002)) {
					userCellDescriptions_ = new com.google.protobuf.UnmodifiableLazyStringList(userCellDescriptions_);
					bitField0_ = (bitField0_ & ~0x00000002);
				}
				result.userCellDescriptions_ = userCellDescriptions_;
				if (((bitField0_ & 0x00000004) == 0x00000004)) {
					quantifiedPropertyNames_ =
							new com.google.protobuf.UnmodifiableLazyStringList(quantifiedPropertyNames_);
					bitField0_ = (bitField0_ & ~0x00000004);
				}
				result.quantifiedPropertyNames_ = quantifiedPropertyNames_;
				if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
					to_bitField0_ |= 0x00000001;
				}
				result.idxMax_ = idxMax_;
				if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
					to_bitField0_ |= 0x00000002;
				}
				result.imageDimy_ = imageDimy_;
				if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
					to_bitField0_ |= 0x00000004;
				}
				result.imageDimx_ = imageDimx_;
				if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
					to_bitField0_ |= 0x00000008;
				}
				result.imageDimz_ = imageDimz_;
				if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
					to_bitField0_ |= 0x00000010;
				}
				result.xMicronCalibration_ = xMicronCalibration_;
				if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
					to_bitField0_ |= 0x00000020;
				}
				result.yMicronCalibration_ = yMicronCalibration_;
				if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
					to_bitField0_ |= 0x00000040;
				}
				result.zMicronCalibration_ = zMicronCalibration_;
				result.bitField0_ = to_bitField0_;
				return result;
			}

			@Override
			public Builder mergeFrom(pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory other) {
				if (other == pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegDirectory.getDefaultInstance())
					return this;
				if (!other.protobufInfo_.isEmpty()) {
					if (protobufInfo_.isEmpty()) {
						protobufInfo_ = other.protobufInfo_;
						bitField0_ = (bitField0_ & ~0x00000001);
					} else {
						ensureProtobufInfoIsMutable();
						protobufInfo_.addAll(other.protobufInfo_);
					}

				}
				if (!other.userCellDescriptions_.isEmpty()) {
					if (userCellDescriptions_.isEmpty()) {
						userCellDescriptions_ = other.userCellDescriptions_;
						bitField0_ = (bitField0_ & ~0x00000002);
					} else {
						ensureUserCellDescriptionsIsMutable();
						userCellDescriptions_.addAll(other.userCellDescriptions_);
					}

				}
				if (!other.quantifiedPropertyNames_.isEmpty()) {
					if (quantifiedPropertyNames_.isEmpty()) {
						quantifiedPropertyNames_ = other.quantifiedPropertyNames_;
						bitField0_ = (bitField0_ & ~0x00000004);
					} else {
						ensureQuantifiedPropertyNamesIsMutable();
						quantifiedPropertyNames_.addAll(other.quantifiedPropertyNames_);
					}

				}
				if (other.hasIdxMax()) {
					setIdxMax(other.getIdxMax());
				}
				if (other.hasImageDimy()) {
					setImageDimy(other.getImageDimy());
				}
				if (other.hasImageDimx()) {
					setImageDimx(other.getImageDimx());
				}
				if (other.hasImageDimz()) {
					setImageDimz(other.getImageDimz());
				}
				if (other.hasXMicronCalibration()) {
					setXMicronCalibration(other.getXMicronCalibration());
				}
				if (other.hasYMicronCalibration()) {
					setYMicronCalibration(other.getYMicronCalibration());
				}
				if (other.hasZMicronCalibration()) {
					setZMicronCalibration(other.getZMicronCalibration());
				}
				return this;
			}

			@Override
			public final boolean isInitialized() {
				return true;
			}

			@Override
			public Builder mergeFrom(com.google.protobuf.CodedInputStream input,
					com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				while (true) {
					int tag = input.readTag();
					switch (tag) {
						case 0:

							return this;
						default: {
							if (!parseUnknownField(input, extensionRegistry, tag)) {

								return this;
							}
							break;
						}
						case 10: {
							pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.Builder subBuilder =
									pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.newBuilder();
							input.readMessage(subBuilder, extensionRegistry);
							addProtobufInfo(subBuilder.buildPartial());
							break;
						}
						case 18: {
							ensureUserCellDescriptionsIsMutable();
							userCellDescriptions_.add(input.readBytes());
							break;
						}
						case 26: {
							ensureQuantifiedPropertyNamesIsMutable();
							quantifiedPropertyNames_.add(input.readBytes());
							break;
						}
						case 37: {
							bitField0_ |= 0x00000008;
							idxMax_ = input.readFloat();
							break;
						}
						case 45: {
							bitField0_ |= 0x00000010;
							imageDimy_ = input.readFloat();
							break;
						}
						case 53: {
							bitField0_ |= 0x00000020;
							imageDimx_ = input.readFloat();
							break;
						}
						case 61: {
							bitField0_ |= 0x00000040;
							imageDimz_ = input.readFloat();
							break;
						}
						case 69: {
							bitField0_ |= 0x00000080;
							xMicronCalibration_ = input.readFloat();
							break;
						}
						case 77: {
							bitField0_ |= 0x00000100;
							yMicronCalibration_ = input.readFloat();
							break;
						}
						case 85: {
							bitField0_ |= 0x00000200;
							zMicronCalibration_ = input.readFloat();
							break;
						}
					}
				}
			}

			private int bitField0_;

			// repeated .protobuf_package.SegInfo protobuf_info = 1;
			private java.util.List<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> protobufInfo_ =
					java.util.Collections.emptyList();

			public void ensureProtobufInfoIsMutable() {
				if (!((bitField0_ & 0x00000001) == 0x00000001)) {
					protobufInfo_ =
							new java.util.ArrayList<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo>(
									protobufInfo_);
					bitField0_ |= 0x00000001;
				}
			}

			@Override
			public java.util.List<pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> getProtobufInfoList() {
				return java.util.Collections.unmodifiableList(protobufInfo_);
			}

			@Override
			public int getProtobufInfoCount() {
				return protobufInfo_.size();
			}

			@Override
			public pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo getProtobufInfo(int index) {
				return protobufInfo_.get(index);
			}

			public Builder setProtobufInfo(int index, pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureProtobufInfoIsMutable();
				protobufInfo_.set(index, value);

				return this;
			}

			public Builder setProtobufInfo(int index,
					pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.Builder builderForValue) {
				ensureProtobufInfoIsMutable();
				protobufInfo_.set(index, builderForValue.build());

				return this;
			}

			public Builder addProtobufInfo(pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureProtobufInfoIsMutable();
				protobufInfo_.add(value);

				return this;
			}

			public Builder addProtobufInfo(int index, pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureProtobufInfoIsMutable();
				protobufInfo_.add(index, value);

				return this;
			}

			public Builder addProtobufInfo(
					pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.Builder builderForValue) {
				ensureProtobufInfoIsMutable();
				protobufInfo_.add(builderForValue.build());

				return this;
			}

			public Builder addProtobufInfo(int index,
					pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo.Builder builderForValue) {
				ensureProtobufInfoIsMutable();
				protobufInfo_.add(index, builderForValue.build());

				return this;
			}

			public Builder addAllProtobufInfo(
					java.lang.Iterable<? extends pipeline.plugins.c_plugins.ProtobufSeedsOrCells.SegInfo> values) {
				ensureProtobufInfoIsMutable();
				super.addAll(values, protobufInfo_);

				return this;
			}

			public Builder clearProtobufInfo() {
				protobufInfo_ = java.util.Collections.emptyList();
				bitField0_ = (bitField0_ & ~0x00000001);

				return this;
			}

			public Builder removeProtobufInfo(int index) {
				ensureProtobufInfoIsMutable();
				protobufInfo_.remove(index);

				return this;
			}

			// repeated string userCellDescriptions = 2;
			private com.google.protobuf.LazyStringList userCellDescriptions_ =
					com.google.protobuf.LazyStringArrayList.EMPTY;

			public void ensureUserCellDescriptionsIsMutable() {
				if (!((bitField0_ & 0x00000002) == 0x00000002)) {
					userCellDescriptions_ = new com.google.protobuf.LazyStringArrayList(userCellDescriptions_);
					bitField0_ |= 0x00000002;
				}
			}

			@Override
			public java.util.List<String> getUserCellDescriptionsList() {
				return java.util.Collections.unmodifiableList(userCellDescriptions_);
			}

			@Override
			public int getUserCellDescriptionsCount() {
				return userCellDescriptions_.size();
			}

			@Override
			public String getUserCellDescriptions(int index) {
				return userCellDescriptions_.get(index);
			}

			public Builder setUserCellDescriptions(int index, String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureUserCellDescriptionsIsMutable();
				userCellDescriptions_.set(index, value);

				return this;
			}

			public Builder addUserCellDescriptions(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureUserCellDescriptionsIsMutable();
				userCellDescriptions_.add(value);

				return this;
			}

			public Builder addAllUserCellDescriptions(java.lang.Iterable<String> values) {
				ensureUserCellDescriptionsIsMutable();
				super.addAll(values, userCellDescriptions_);

				return this;
			}

			public Builder clearUserCellDescriptions() {
				userCellDescriptions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000002);

				return this;
			}

			void addUserCellDescriptions(com.google.protobuf.ByteString value) {
				ensureUserCellDescriptionsIsMutable();
				userCellDescriptions_.add(value);

			}

			// repeated string quantifiedPropertyNames = 3;
			private com.google.protobuf.LazyStringList quantifiedPropertyNames_ =
					com.google.protobuf.LazyStringArrayList.EMPTY;

			public void ensureQuantifiedPropertyNamesIsMutable() {
				if (!((bitField0_ & 0x00000004) == 0x00000004)) {
					quantifiedPropertyNames_ = new com.google.protobuf.LazyStringArrayList(quantifiedPropertyNames_);
					bitField0_ |= 0x00000004;
				}
			}

			@Override
			public java.util.List<String> getQuantifiedPropertyNamesList() {
				return java.util.Collections.unmodifiableList(quantifiedPropertyNames_);
			}

			@Override
			public int getQuantifiedPropertyNamesCount() {
				return quantifiedPropertyNames_.size();
			}

			@Override
			public String getQuantifiedPropertyNames(int index) {
				return quantifiedPropertyNames_.get(index);
			}

			public Builder setQuantifiedPropertyNames(int index, String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureQuantifiedPropertyNamesIsMutable();
				quantifiedPropertyNames_.set(index, value);

				return this;
			}

			public Builder addQuantifiedPropertyNames(String value) {
				if (value == null) {
					throw new NullPointerException();
				}
				ensureQuantifiedPropertyNamesIsMutable();
				quantifiedPropertyNames_.add(value);

				return this;
			}

			public Builder addAllQuantifiedPropertyNames(java.lang.Iterable<String> values) {
				ensureQuantifiedPropertyNamesIsMutable();
				super.addAll(values, quantifiedPropertyNames_);

				return this;
			}

			public Builder clearQuantifiedPropertyNames() {
				quantifiedPropertyNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
				bitField0_ = (bitField0_ & ~0x00000004);

				return this;
			}

			void addQuantifiedPropertyNames(com.google.protobuf.ByteString value) {
				ensureQuantifiedPropertyNamesIsMutable();
				quantifiedPropertyNames_.add(value);

			}

			// optional float idx_max = 4 [default = 0];
			private float idxMax_;

			@Override
			public boolean hasIdxMax() {
				return ((bitField0_ & 0x00000008) == 0x00000008);
			}

			@Override
			public float getIdxMax() {
				return idxMax_;
			}

			public Builder setIdxMax(float value) {
				bitField0_ |= 0x00000008;
				idxMax_ = value;

				return this;
			}

			public Builder clearIdxMax() {
				bitField0_ = (bitField0_ & ~0x00000008);
				idxMax_ = 0F;

				return this;
			}

			// optional float image_dimy = 5;
			private float imageDimy_;

			@Override
			public boolean hasImageDimy() {
				return ((bitField0_ & 0x00000010) == 0x00000010);
			}

			@Override
			public float getImageDimy() {
				return imageDimy_;
			}

			public Builder setImageDimy(float value) {
				bitField0_ |= 0x00000010;
				imageDimy_ = value;

				return this;
			}

			public Builder clearImageDimy() {
				bitField0_ = (bitField0_ & ~0x00000010);
				imageDimy_ = 0F;

				return this;
			}

			// optional float image_dimx = 6;
			private float imageDimx_;

			@Override
			public boolean hasImageDimx() {
				return ((bitField0_ & 0x00000020) == 0x00000020);
			}

			@Override
			public float getImageDimx() {
				return imageDimx_;
			}

			public Builder setImageDimx(float value) {
				bitField0_ |= 0x00000020;
				imageDimx_ = value;

				return this;
			}

			public Builder clearImageDimx() {
				bitField0_ = (bitField0_ & ~0x00000020);
				imageDimx_ = 0F;

				return this;
			}

			// optional float image_dimz = 7;
			private float imageDimz_;

			@Override
			public boolean hasImageDimz() {
				return ((bitField0_ & 0x00000040) == 0x00000040);
			}

			@Override
			public float getImageDimz() {
				return imageDimz_;
			}

			public Builder setImageDimz(float value) {
				bitField0_ |= 0x00000040;
				imageDimz_ = value;

				return this;
			}

			public Builder clearImageDimz() {
				bitField0_ = (bitField0_ & ~0x00000040);
				imageDimz_ = 0F;

				return this;
			}

			// optional float x_micron_calibration = 8;
			private float xMicronCalibration_;

			@Override
			public boolean hasXMicronCalibration() {
				return ((bitField0_ & 0x00000080) == 0x00000080);
			}

			@Override
			public float getXMicronCalibration() {
				return xMicronCalibration_;
			}

			public Builder setXMicronCalibration(float value) {
				bitField0_ |= 0x00000080;
				xMicronCalibration_ = value;

				return this;
			}

			public Builder clearXMicronCalibration() {
				bitField0_ = (bitField0_ & ~0x00000080);
				xMicronCalibration_ = 0F;

				return this;
			}

			// optional float y_micron_calibration = 9;
			private float yMicronCalibration_;

			@Override
			public boolean hasYMicronCalibration() {
				return ((bitField0_ & 0x00000100) == 0x00000100);
			}

			@Override
			public float getYMicronCalibration() {
				return yMicronCalibration_;
			}

			public Builder setYMicronCalibration(float value) {
				bitField0_ |= 0x00000100;
				yMicronCalibration_ = value;

				return this;
			}

			public Builder clearYMicronCalibration() {
				bitField0_ = (bitField0_ & ~0x00000100);
				yMicronCalibration_ = 0F;

				return this;
			}

			// optional float z_micron_calibration = 10;
			private float zMicronCalibration_;

			@Override
			public boolean hasZMicronCalibration() {
				return ((bitField0_ & 0x00000200) == 0x00000200);
			}

			@Override
			public float getZMicronCalibration() {
				return zMicronCalibration_;
			}

			public Builder setZMicronCalibration(float value) {
				bitField0_ |= 0x00000200;
				zMicronCalibration_ = value;

				return this;
			}

			public Builder clearZMicronCalibration() {
				bitField0_ = (bitField0_ & ~0x00000200);
				zMicronCalibration_ = 0F;

				return this;
			}

			// @@protoc_insertion_point(builder_scope:protobuf_package.SegDirectory)
		}

		static {
			defaultInstance = new SegDirectory(true);
			defaultInstance.initFields();
		}

		// @@protoc_insertion_point(class_scope:protobuf_package.SegDirectory)
	}

	static {
	}

	// @@protoc_insertion_point(outer_class_scope)
}
